Table of Contents:
# API vs. Framework vs. Library
# What is Angular? 
# React vs. Angular
# Inversion of Control (IOC)
# Installation
# Node.js  vs. nvm vs. npm
# Creating new Angular project
# Introduction about build
# Just in Time vs. Ahead of Time compilation
# Creating a project
# How Angular app runs?
# What is SPA? (Single Page Application)

# ng serve vs. ng build:
# Modules in angular
# Components in angular
# Data binding in Angular
# Directives in Angular.
# @Input() and @Output() in Angular
# Template Reference Variables in Angular
# Why Not Use JS DOM Query Methods? instead of template variables?
# How `document.querySelector()` Works in an Angular Application
# @ViewChild & @ViewChildren in Angular




# API vs. Framework vs. Library
--------------------------------
1) API:
> A set of rules and protocols that allow different software components to communicate.
> Defines how software interacts with external services or components.
> Example: REST API (e.g., GitHub API, Twitter API) lets you fetch or modify data.
> Think of an API as a menu in a restaurant – it tells you what you can order but doesn’t tell you how the food is prepared.

2) Library:
> A collection of pre-written code that you can call and use in your application to simplify development.
> You call functions from the library when needed.
> Example: Lodash (JavaScript utility functions), NumPy (Python for numerical operations), jQuery (DOM manipulation), React
> Think of a library as a toolbox – you pick and use the tools (functions) as required.


3) Framework:
> A structured environment that dictates how you should organize and build your application.
> It calls your code and provides a set of rules and conventions (Inversion of Control).
> Example: Angular (Complete front-end framework), Spring Boot (Java back-end framework), Django (Python web framework)
> Think of Angular as a full construction kit —it provides everything.

===========================================================================================================================================

# What is Angular?
--------------------------------
> Angular is a web framework that empowers developers to build fast, reliable applications.
> It is maintained by a dedicated team at Google.
> Angular provides a broad suite of tools, APIs, and libraries to simplify and streamline the development workflow. 
> Angular gives you a solid platform on which to build fast, reliable applications that scale with both the size of the team and the size of the codebase.

===========================================================================================================================================

# React vs. Angular
--------------------------------
Great question! In JavaScript, the distinction between API, Library, and Framework becomes clearer when looking at React and Angular:

React (Library) vs. Angular (Framework)

| Feature            | React (Library) | Angular (Framework) |
|--------------------|-------------------|-----------------------|
| Definition      | A UI library focused on building components | A full-fledged framework for building web apps |
| Control Flow   | You call React functions (`useState`, `useEffect`) | Angular dictates the app structure and calls your code |
| Opinionated?   | No, you choose your tools (e.g., state management, routing) | Yes, Angular provides built-in solutions (RxJS, Forms, Router) |
| Flexibility    | High—you can use React with any backend, state manager, etc. | Lower—you follow Angular's structure and use its modules |
| Inversion of Control (IoC) | No (you control the flow) | Yes (Angular manages component lifecycle) |

===========================================================================================================================================

# Inversion of Control (IOC):
------------------------------
> IOC is a design principle where the control of program flow is shifted from your code to an external system (like a framework). 
> Instead of you calling functions, the framework calls your code when needed.


Example in JavaScript: IoC vs. No IoC

i)Without IoC (You Control the Flow)
In a normal library, you call functions when needed:

// Example using a library (React)
function fetchData() {
  console.log("Fetching data...");
}

fetchData(); // You explicitly call the function
you are in control—you decide when to call fetchData().


ii) With IoC (Framework Controls the Flow)
In a framework, it calls your code when required, following its rules:

// Example in Angular (Framework)
@Component({
  selector: 'app-example',
  template: '<p>Example</p>'
})
export class ExampleComponent implements OnInit {
  ngOnInit() {
    console.log("Component initialized!"); // Angular calls this method
  }
}

Here, Angular controls the lifecycle—it calls `ngOnInit()` when the component initializes.

===========================================================================================================================================

# Installation
-----------------
> Node js should be there.
> "npm install -g @angular/cli" in cmd.

> Checking version:
  node -v
  npm -v
  ng -v
  
===========================================================================================================================================

# Node.js  vs. nvm vs. npm
---------------------------
1) Node.js
- What is it?
  - A JavaScript runtime that allows you to run JavaScript outside the browser.
  - Comes with built-in modules for file system operations, HTTP servers, etc.

- Key Features:
  - Runs JavaScript on the backend.
  - Uses the V8 engine (same as Chrome).
  - Supports asynchronous programming.

- Command to Check Version: 
  node -v
  
- Example Use:
  console.log("Hello from Node.js!");

  Run it with: node script.js

---

2) NVM (Node Version Manager)
- What is it?
  - A tool to manage multiple versions of Node.js on your system.

- Key Features:
  - Easily switch between Node versions.
  - Install/update Node.js without affecting global settings.
  
- Commands:
  - Install a specific Node version:  
    nvm install 18

  - Use a specific version:  
    nvm use 16

  - List installed versions:  
    nvm list

- Think of NVM as a Node.js version switcher—use different versions for different projects.

---

3) NPM (Node Package Manager)
- What is it?
  - A package manager that comes with Node.js.

- Key Features:
  - Installs and manages JavaScript libraries and dependencies.
  - Uses a package.json file to track project dependencies.

- Commands:
  - Check version:
    npm -v
	
  - Install a package globally:
    npm install -g @angular/cli

  - Install project dependencies:  
    npm install

- Think of NPM as a marketplace for JavaScript libraries—it lets you install and manage packages.

===========================================================================================================================================

# Creating new Angular project
- ng new proj-name

- You'll be asked some configuration questions:
  - Would you like to add Angular routing? → Yes/No
  - Which stylesheet format would you like to use? → Choose CSS, SCSS, LESS, etc.
  
- Move into the project folder:
cd proj-name

- Start the development server:
ng serve

- or specify a port:
ng serve --port 4201

- Starts the Angular development server and automatically opens the app in the default web browser.
ng serve --open (Shorthand: ng s -o)


- Build the Angular Project
To create a production build: ng build --prod
This generates optimized files inside the dist/ folder.

===========================================================================================================================================

# Introduction about build
---------------------------
> In Angular (or any frontend framework), "build" refers to the process of converting your source code into an optimized format that browsers can understand. 
> This includes compiling TypeScript, bundling files, minifying, and optimizing performance.  

-Why Is "Build" Needed? 
- Browsers don’t understand TypeScript → It must be converted to JavaScript.  
- Angular uses modules and components → They must be bundled into fewer files.  
- Performance optimization → Reduces file size, removes unused code, and speeds up execution.  
- Security → Hides the original source code to prevent direct modification.  


-What Does the Build Contain?
When you run:  ng build --configuration=production
It generates a /dist/ (distribution) folder containing optimized files like:

| File | Purpose |
|------|---------|
| `index.html`   | The main HTML file that loads the app |
| `main.js`      | Compiled JavaScript from your Angular components |
| `runtime.js`   | Bootstraps the Angular app |
| `polyfills.js` | Ensures compatibility with older browsers |
| `styles.css`   | Minified global styles |
| `assets/`      | Static files like images and fonts |
-----------------

-Development vs. Production Build 
| Feature            | `ng serve` (Dev Mode)     | `ng build --prod` (Prod Mode)    |
|--------------------|---------------------------|----------------------------------|
| Optimization   | No                        | Yes (minification, tree-shaking) |
| File Size      | Large                     | Small                            |
| Debugging      | Easier (with source maps) | Harder (obfuscated code)         |
| Performance    | Slower 					 | Faster                           |
| Error Handling | More logging              | Less logging (for security)      |

===========================================================================================================================================

# Just in Time vs. Ahead of Time compilation:
---------------------------------------------
Both JIT (Just-in-Time) and AOT (Ahead-of-Time) involve compilation, but they differ in 'when' and 'how' the compilation happens.

1) JIT Compilation (Just-in-Time)
- When does it happen? 
  JIT compiles the Angular templates at runtime, i.e., when the application is being loaded in the browser.
  
- How does it work?
  1. Angular loads the app's JavaScript (including components, services, etc.).
  2. The Angular compiler runs in the browser and compiles the templates and components into executable code.
  3. Only then does the app start rendering in the browser.

- Impact: Since the compilation happens in the browser during runtime, the initial loading of the app can be slower, and the bundle size is larger because the compiler is included.

---

2) AOT Compilation (Ahead-of-Time)
- When does it happen?
  AOT compiles the Angular templates before the app is run (i.e., at build time, during the ng build process).

- How does it work? 
  1. The Angular compiler is run during the build to pre-compile the TypeScript templates and HTML into optimized JavaScript code.
  2. The compiled templates are included directly in the final bundle, which is served to the browser.
  3. Since the templates are already compiled, the browser doesn't need to run the Angular compiler during execution.

- Impact: AOT results in a smaller and faster app because there's no need for the Angular compiler at runtime, and the browser only receives the already compiled code.

---
Key Difference:
- JIT compiles templates in the browser when the app is loaded.
- AOT compiles templates before the app is served, producing optimized code.

- Why Does AOT Improve Performance?
	- Smaller Bundle: Since templates are precompiled, no need to send the compiler code to the browser.
	- Faster Execution: Precompiled templates are ready to be executed by the browser directly, reducing the time spent compiling in the browser.
	- Early Error Detection: AOT can catch template errors during the build, helping to avoid runtime errors.

===========================================================================================================================================

# Creating a project:
ng new Proj-name

This will create following folder structure.

> .angular
> node_modules
> src
	> app
		> app-routing.module.ts
		> app.module.ts
		> app.component.html
		> app.component.scss
		> app.component.ts
		> app.component.spec.ts
	
	> assets
		> .gitkeep
		
	> environments
		> environment.ts
		> environment.prod.ts
	
	> favicon.ico
	> index.html
	> main.ts
	> polyfills.ts
	> styles.css
	> test.ts

> .browserslistrc
> .editorconfig
> .gitignore
> angular.json
> karma.conf.js
> package-lock.json
> package.json
> README.md
> tsconfig.app.json
> tsconfig.json
> tsconfig.spec.json


Functinalities of each file are as follows:

> `.angular/`
- This is a cache folder used by the Angular CLI to store temporary build artifacts.
- It speeds up builds by caching intermediate results.
- You can delete this folder safely; Angular will regenerate it when needed.

> `node_modules/`
- Contains all the installed dependencies (packages) listed in `package.json`.
- This folder is created after running `npm install`.
- It includes Angular itself, third-party libraries, and build tools.

> `src/`
- The main source folder where the actual application code resides.
- Contains the `app/`, `assets/`, and `environments/` folders, along with important configuration files.

> `src/app/`
- This folder contains the root application module (`app.module.ts`) and the main component (`app.component.ts`).
- Additional components, services, and modules are typically created inside this folder.

> `src/app/app-routing.module.ts`
- Defines the application's routes using the Angular Router.
- Used to configure navigation between different components/pages.

> `src/app/app.module.ts`
- The root module of the application.
- Declares components, imports necessary Angular modules, and configures services.
- Every Angular application must have at least one module (usually `AppModule`).

> `src/app/app.component.ts`
- The main component of the application (bootstrapped in `app.module.ts`).
- Defines the logic for the root component.

> `src/app/app.component.html`
- The template file (UI) for the `AppComponent`.

> `src/app/app.component.scss`
- The styles specific to `AppComponent` (written in SCSS, but can be changed to CSS).

> `src/app/app.component.spec.ts`
- The unit test file for `AppComponent`.
- Uses Jasmine for testing.

> `src/assets/`
- This folder is used for storing static assets like images, fonts, and JSON files.
- The `assets/` folder is copied to the `dist/` folder when you build the project.

> `src/assets/.gitkeep`
- An empty file used to ensure the `assets/` folder is tracked in Git (Git does not track empty folders).

> `src/environments/`
- Contains environment-specific configuration files.

> `src/environments/environment.ts`
- Contains settings for the development environment.

> `src/environments/environment.prod.ts`
- Contains settings for the production environment.
- Used when running `ng build --prod`.

> `src/favicon.ico`
- The favicon (icon shown in the browser tab).

> `src/index.html`
- The main HTML file that loads the Angular app.
- Contains a `<body>` tag where `AppComponent` is inserted.

> `src/main.ts`
- The entry point of the application.
- Bootstraps the `AppModule` and starts the Angular app.

> `src/polyfills.ts`
- Includes necessary polyfills to support older browsers.

> `src/styles.css`
- The global stylesheet for the application.

> `src/test.ts`
- Configures unit testing using Karma.

---

> `.browserslistrc`
- Specifies which browsers the application should support.
- Used by tools like Autoprefixer and Babel.

> `.editorconfig`
- Defines coding style guidelines (like indentation and line endings).
- Helps maintain consistency across different code editors.

> `.gitignore`
- Specifies which files and folders should be ignored by Git.
- Commonly ignores `node_modules/`, `dist/`, and other unnecessary files.

> `angular.json`
- The main configuration file for the Angular CLI.
- Defines build options, assets, styles, scripts, and environment settings.

> `karma.conf.js`
- The configuration file for Karma, which runs unit tests.

> `package-lock.json`
- Automatically generated when dependencies are installed.
- Ensures that the exact dependency versions are used in all installations.

> `package.json`
- Contains project metadata and lists dependencies.
- Defines scripts like `ng serve`, `ng build`, and `ng test`.

> `README.md`
- A documentation file containing information about the project.
- Typically includes setup instructions.

> `tsconfig.app.json`
- TypeScript configuration file specifically for the Angular application.

> `tsconfig.json`
- The global TypeScript configuration file.
- Defines TypeScript compiler options.

> `tsconfig.spec.json`
- TypeScript configuration for test files.

===========================================================================================================================================

# How Angular app runs?

1. Entry Point - `main.ts`
-------------------------------
When you run `ng serve`, `ng build`, or `ng start`, Angular starts execution from `src/main.ts`, which is the main entry point of the application.  

Inside `main.ts`: 
import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
import { AppModule } from './app/app.module';

platformBrowserDynamic().bootstrapModule(AppModule)
  .catch(err => console.error(err));


What happens here:  
- `platformBrowserDynamic()` creates a dynamic platform for running Angular applications in the browser. It returns an instance of PlatformRef,
   which is a reference to the Angular platform. It provides methods to bootstrap modules, destroy the platform, and access the injector.
- `.bootstrapModule(AppModule)` loads the `AppModule`, the root module of the application. And this method returns a promise.
- `.catch(err => console.error(err))` catches any errors during the bootstrapping process.  



2. Bootstrapping `AppModule`  
-----------------------------
Angular loads the `AppModule`, which is the root module of the application.  

Inside `app.module.ts`:
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';

@NgModule({
  declarations: [AppComponent], 
  imports: [BrowserModule], 
  bootstrap: [AppComponent] 
})
export class AppModule { }


What happens here:  
- `@NgModule` decorator marks this as an Angular module.  
- `declarations` registers components, directives, and pipes.  
- `imports` loads required modules like `BrowserModule`, which is needed to run an Angular app in a browser.  
- `bootstrap` specifies `AppComponent` as the starting component.  



3. Root Component Initialization  
----------------------------------
Once `AppModule` is loaded, Angular initializes `AppComponent`, which serves as the root component of the application.  

Inside `app.component.ts`:
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss']
})
export class AppComponent {
  title = 'Practice';
}

What happens here:  
- `@Component` decorator marks this as an Angular component defines metadata for `AppComponent`.  
- `selector: 'app-root'` means Angular will replace `<app-root></app-root>` with this component’s HTML.  


4. `index.html` Loads the Root Component  
---------------------------------------
The `index.html` file in `src` acts as the main container for the Angular app.  

Inside `index.html`:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Practice</title>
</head>
<body>
  <app-root></app-root> <!-- This will be replaced with AppComponent -->
</body>
</html>

What happens here:  
- The `<app-root>` tag is a placeholder.  
- When Angular starts, it replaces `<app-root>` with `AppComponent`'s HTML.  



5. Rendering and Change Detection  
----------------------------------
- Angular compiles the templates using JIT (Just-in-Time) in development or AOT (Ahead-of-Time) in production.  
- The rendered HTML is inserted into `index.html`.  
- Change detection ensures that UI updates happen whenever the component’s data changes.  


Summary of the Angular Startup Flow  
---------------------------------------
1. `main.ts` starts the application and calls `bootstrapModule(AppModule)`.  
2. `AppModule` loads all necessary components and dependencies.  
3. `AppComponent` is bootstrapped as the main component.  
4. `index.html` contains the `<app-root>` tag, which Angular replaces with `AppComponent`'s content.  
5.  Angular compiles templates, initializes components, and sets up change detection.  

============================================================================================================================================

# What is SPA? (Single Page Application)

> A Single Page Application (SPA) is a type of web application that loads a single HTML page and dynamically updates the content without reloading the entire page. 
> Angular is designed for building SPAs.


How does an Angular SPA work?
-----------------------------
i) Bootstraps the Angular app:
platformBrowserDynamic() initializes Angular and loads the root module (AppModule).
This ensures that the entire application runs within a single HTML page (index.html).

ii) Router manages navigation without page reloads:
In a traditional multi-page app, every user action (e.g., clicking a link) triggers a full-page reload.
In an SPA, Angular’s Router Module intercepts navigation and updates only the necessary parts of the page.

iii) Dynamically updates the DOM
Instead of fetching new HTML files from the server, Angular modifies the existing page using JavaScript.


How Components are Stored and Rendered in Angular?
-----------------------------------------------------
1️) At the start (ng serve or ng build)
> Angular compiles all components (.ts, .html, .css) into optimized JavaScript files.
> These files are loaded into the browser when the application first starts.
> The browser does not need to request new HTML files from the server.

2️) When navigating between pages
> Angular does not reload the page.
> Instead, it removes the old component from the DOM and inserts the new component inside <router-outlet>.
> The JavaScript in memory handles this transition without contacting the server.

> The server is only contacted once unless you refresh or fetch new data via an API.



============================================================================================================================================

# ng serve vs. ng build:

- When we deploy app to browser via any of above methods, after compilation, the main.js file,
  which contains all of the app's optimized code, polyfill.js, styles.css all are injected
  into index.html.
- Ex:
<!doctype html>
  <html lang="en">
    <head>
      ...
      <link rel="icon" type="image/x-icon" href="favicon.ico">
      <link rel="stylesheet" href="styles.css"></head>
    <body>
      <app-root></app-root>
      <script src="polyfills.js" type="module">
      </script><script src="main.js" type="module"></script>
    </body>
  </html>

1. ng serve: (For Development)
- Compiles the Angular application in memory without writing files to the disk.
- When you run ng serve, the Angular CLI compiles the application in-memory using Webpack's Dev Server.
- The compiled files (HTML, CSS, JS) are not written to disk (i.e., not stored in the dist/ folder).
- Instead, they are stored temporarily in RAM and served directly from there.
- This makes hot-reloading faster because there’s no need to read/write files on disk.
- The .angular folder is stored on disk, but it mostly contains build cache and incremental compilation data.
- This helps speed up subsequent ng serve runs, but it is not the actual compiled output.
- ng serve Serves the application at http://localhost:4200/ by default.
- It automatically reloads the page when files are modified.
- When to use it:
  - During development when you need live reloading and fast iterations.
  - When testing your app locally without worrying about deployment.
- When we do ng serve, JIT compilation occurs and code minification is minimal not complete minification.


2. ng build: (For Production/Deployment)
- Compiles the Angular app into static files (HTML, CSS, JS, assets).
- Generates output in the dist/ folder stored in disk.
- Uses ahead-of-time (AOT) compilation to optimize performance.
- Minifies and optimizes files.
- When to use it:
  - When you need to deploy the app to a server or cloud hosting.
  - When you need an optimized build for better performance.
- Does NOT serve the app (you need an external server like http-server, Nginx, Apache, or Firebase Hosting).
- To deploy that build in browser we can use http-server.
  - npm install -g http-server
  - Go to dist/ directory where html, js files are there.
  - http-server -p 4200 // Will start the server.





| Feature               | `ng serve`                               | `ng build` |
|-----------------------|------------------------------------------|-----------------------|
| Purpose               | Development (Live Preview)               | Production (Deployment) |
| Creates `dist/`?      |  No                                      |  Yes |
| Hot Reloading?        |  Yes                                     |  No |
| Optimized Code?       |  No                                      |  Yes |
| Server Required?      |  No (uses Webpack Dev Server)            |  Yes (e.g., `http-server`, Nginx) |
| Minification          |  No (only bundling & some optimizations) |  Yes (fully minified using Terser) |
| Tree Shaking          |  Partial                                 |  Full tree shaking  |
| Dead Code Elimination |  No                                      |  Yes |
| Source Maps           |  Enabled (for debugging)                 |  Disabled (unless manually enabled) |
| File Compression      |  No                                      |  Yes  |


Note:
-----
- When you run the ng build (build only) or ng serve (build and serve locally) CLI commands, the type of compilation (JIT or AOT) depends on the value of the aot property in your build configuration specified in angular.json. 
- By default, aot is set to true for new CLI applications.
- If its not set, then serve-jit, build-aot.

============================================================================================================================================


# Modules in angular.
- Angular modules help organize and manage different parts of an application.
- They group related components, directives, pipes, and services, making the app scalable, maintainable, and modular.

- Creating a feature module via CLI: 
ng g m module-name

- Creating component within a feature module via CLI:
ng g c module-name/component-name

---

1. What is an Angular Module?
An Angular module is a container for a set of related functionality in an Angular application. 

It helps:
- Organize code by grouping related components, services, and directives.
- Improve performanceby enabling lazy loading of features.
- Manage dependencies efficiently.

- Syntax: Creating a Module
  - Modules are created using the `@NgModule` decorator.

  -Ex:
    import { NgModule } from '@angular/core';
    import { BrowserModule } from '@angular/platform-browser';
    import { AppComponent } from './app.component';

    @NgModule({
      declarations: [AppComponent], // Components, Directives, Pipes
      imports: [BrowserModule], // Import other modules
      providers: [], // Services
      exports: [UserComponent] // Export the component to be used outside module.
      bootstrap: [AppComponent] // Root component
    })
    export class AppModule {}


---

2. Why are Angular Modules Used?
1. Code Organization– Groups related features together.
2. Scalability– Helps build large applications in a modular way.
3. Reusability– Feature modules can be reused across different applications.
4. Lazy Loading– Improves performance by loading modules only when needed.
5. Dependency Management– Handles service providers efficiently.

---

3. Types of Angular Modules
Angular has different types of modules, each serving a specific purpose.

1️⃣ Root Module (`AppModule`)
- The main module that bootstraps the Angular app.
- Declared in `app.module.ts`.


@NgModule({
  bootstrap: [AppComponent]
})
export class AppModule {}


---

2️⃣ Feature Modules
- Used to organize specific functionality.
- Example: A `UserModule` for user-related components.


@NgModule({
  declarations: [UserComponent],
  imports: [CommonModule],
  exports: [UserComponent]
})
export class UserModule {}


Then, import it into `AppModule`:

import { UserModule } from './user/user.module';

@NgModule({
  imports: [UserModule]
})
export class AppModule {}


---

3️⃣ Shared Module
- Contains reusable components, directives, and pipes.
- Prevents duplication across modules.


@NgModule({
  declarations: [SharedComponent],
  exports: [SharedComponent]
})
export class SharedModule {}


Then, import it into other modules:

import { SharedModule } from '../shared/shared.module';

@NgModule({
  imports: [SharedModule]
})
export class FeatureModule {}


---

4️⃣ Core Module
- Holds singleton services (e.g., authentication, API calls).
- Prevents re-importing services in multiple places.


@NgModule({
  providers: [AuthService]
})
export class CoreModule {}


Import in `AppModule`:

import { CoreModule } from './core/core.module';

@NgModule({
  imports: [CoreModule]
})
export class AppModule {}


---

5️⃣ Routing Module
- Manages application routes.
- Example: `AppRoutingModule` to define all app routes.
- app-routing.module.ts


import { RouterModule, Routes } from '@angular/router';

const routes: Routes = [
  { path: 'home', component: HomeComponent },
  { path: '', redirectTo: 'home' } // Wildcard route
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule {}


---

6️⃣ Lazy-Loaded Module
- Improves performance by loading modules only when needed.


const routes: Routes = [
  { path: 'dashboard', loadChildren: () => import('./dashboard/dashboard.module').then(m => m.DashboardModule) }
];


- `DashboardModule` will only be loaded when the user visits `/dashboard`.

---

4. Advantages of Angular Modules
 Code Organization– Keeps the application structured and maintainable.  
 Reusability– Shared modules reduce duplicate code.  
 Performance Optimization– Lazy loading speeds up initial loading.  
 Separation of Concerns– Each module handles a specific part of the app.  
 Easier Testing– Modules allow for isolated unit testing.  

---

5. Disadvantages of Angular Modules
 Overhead in Small Projects– For very small apps, modules can feel unnecessary.  
 Complexity in Large Apps– Managing multiple modules can become difficult.  
 Extra Configuration Needed– Routing, providers, and lazy loading require setup.  

---

6. Angular Standalone Components (No Modules)
Since Angular 14+, you can build apps without NgModules using Standalone Components.


import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from './app.component';

bootstrapApplication(AppComponent);


- Advantages of Standalone Components:
  - No need to define `NgModule`.
  - Reduces boilerplate.
  - Works well for smaller applications.


- Why NgModules Removed in Angular 14+?
  - Prevents Tree Shaking – Imports the entire module, even if only a few components/services are used.
  - Increases Bundle Size – Unused components/directives remain in the final build.
  - Complex Dependency Management – Providers in NgModule can create unnecessary dependencies.
  - Eager Loading Issues – If a module is imported in AppModule, it gets loaded even if not needed.
  - Extra Boilerplate Code – Developers must declare, import, and export components manually.
  - Slower Initial Loading – Modules increase the initial JavaScript bundle size.

---

7. Summary
| Module Type              | Purpose |
|--------------------------|------------------------------------------------|
| Root Module (`AppModule`)| Bootstraps the app |
| Feature Module           | Groups related functionality |
| Shared Module            | Contains reusable components/pipes/directives |
| Core Module              | Stores singleton services like authentication |
| Routing Module           | Handles application routing |
| Lazy-Loaded Module       | Loads modules only when required for performance |


============================================================================================================================================

# Components in angular

- A Componentin Angular is the building block of an application. 
- It defines the UI (template), behavior (class logic), and styles for a section of the app.

---

1. What is an Angular Component?
A component is a TypeScript class decorated with `@Component`. It has:  
- Template (HTML)→ Defines UI structure  
- Class (TS)→ Defines behavior and logic  
- Styles (CSS/SCSS)→ Defines appearance 
- Unit testing (spec.ts) -> For unit testing

- Ex:

  import { Component } from '@angular/core';

  @Component({
    selector: 'app-root', // HTML tag to use this component
    templateUrl: './app.component.html', // External HTML file
    styleUrls: ['./app.component.css'] // External CSS file
  })
  export class AppComponent {
    title = 'Angular Component Example';
  }


---

2. Why Are Components Used?
✅ Encapsulation– Each component is self-contained.  
✅ Reusability– Can be used multiple times in different parts of the app.  
✅ Modularity– Helps break down the app into small, manageable pieces.  
✅ Separation of Concerns– Keeps UI (`template`) separate from logic (`class`).  
✅ Data Binding– Supports easy interaction between UI and logic.  

---

3. Creating a Component
- You can create a component manually or using Angular CLI.
- ng generate component my-component
- ng g c my-component

- Creating component within a feature module via CLI:
ng g c module-name/component-name

This creates:

my-component/
│── my-component.component.ts  (Logic)
│── my-component.component.html (Template)
│── my-component.component.css  (Styles)
│── my-component.component.spec.ts (Test)


4. Manually Creating a Component
Create a `my-component.component.ts` file:

import { Component } from '@angular/core';

@Component({
  selector: 'app-my-component',
  template: `<h2>Welcome to My Component</h2>`,
  styles: [`h2 { color: blue; }`]
})
export class MyComponent {}

Now, add `<app-my-component></app-my-component>` in `app.component.html` to use it.


Note:
- If a component is generated via, CLI, then its automatically registered in declarations array of app.module.ts.
- For manually created compnent, we need to manually register it in app.module.ts.


---

4. Component Metadata (`@Component` Decorator)
The `@Component` decorator configures the component.


@Component({
  selector: 'app-example', // Custom HTML tag for the component
  template: `// html code`
  or
  templateUrl: './example.component.html', // External template file

  styles: `h3 {
    color: red;
    font-size:x-large
    }
    p {
      background-color: red;
    }`
  or
  styleUrls: ['./example.component.css'], // External styles

  // For Ngmodule less project (Angular 14+)
  standalone: true/false // Optional: Enables Standalone Components (Angular 14+) For (Angular 19 Specifying it not needed)
})

- If using -no--standalone project in Angular 14+, needs to explicilty specify in the cmponents that,
  standalone is false.


Properties of `@Component`
| Property      | Description |
|---------------|------------|
| `selector`    | HTML tag used to include the component |
| `templateUrl` | External HTML file |
| `template`    | Inline HTML template |
| `styleUrls`   | External CSS/SCSS files |
| `styles`      | Inline CSS styles |
| `standalone`  | Enables Standalone Components (Angular 14+) |

---

5. Component Styling
Angular components support:
- Global CSS(applies everywhere).
- Component-specific CSS(scoped to that component).
- Encapsulation Modes.

Encapsulation Modes
| Mode                                   | Behavior |
|----------------------------------------|----------|
| `ViewEncapsulation.Emulated` (default) | CSS applies only to that component. |
| `ViewEncapsulation.None`               | CSS is global. |
| `ViewEncapsulation.ShadowDom`          | Uses Shadow DOM for true encapsulation. |


Example:
@Component({
  selector: 'app-example',
  templateUrl: './example.component.html',
  styleUrls: ['./example.component.css'],
  encapsulation: ViewEncapsulation.None
})


6. Selector
- Custom HTML tag for the component
- <app-header></app-header> whereever these selectors are used, it renders the html of that selector in specified place.
- It can be named anything. But default naming convention is "prefix": "app" (which can be specified in angular.json) + "-" + component name (header)
- Ex: ng g c footer -> Then default selector is "app-footer"

i. Using selectors as an HTML element
- In .ts file,
    @Component (
      {
      selector:'app-first'
      }
    )
- Now it can be used as <app-first></app-first>.

- Best For:
  - Reusable UI components (e.g., <app-header>, <app-footer>, <app-sidebar>).
  - When the component represents a distinct UI block.


ii. Using selectors as an attribute
- In .ts file,
    @Component (
      {
      selector:'[app-first]'
      }
    )
- Now it cannnot be used as <app-first></app-first>. Instead it needs to be used as an attribute as follows.
  <div app-first></div>

- Best For:
  - Directives or behaviors that should be applied to existing elements.
  - When the component adds behavior but does not replace the element.


- Real-World Use Case:
  - Highlight text on hover:  <p appHighlight>Hover over me</p>
  - Add a tooltip: <button appTooltip="Click me!">Info</button>


iii. Using selectors as class
  @Component (
    {
      selector:'.app-first'
    }
  )

- Now it cannnot be used as <app-first></app-first>. Instead it needs to be used as an attribute as follows.
<div class="app-first"></div>

- Best For: 
  - When you want to apply styles via a component without modifying the element structure.
  - If you want multiple elements to behave the same way.


- Real-World Use Case:
Apply a reusable button design: <button class="app-button">Click Me</button>


iv. Using selectors as an ID (Not Recommended)
  @Component (
    {
      selector:'#app-first'
    }
  )

- Now it cannnot be used as <app-first></app-first>. Instead it needs to be used as an attribute as follows.
<div id="app-first"></div>

- Why It's Rarely Used?
  - ID selectors must be unique, so you can only use one per page.
  - Angular components are meant to be reusable.

- When Would This Be Useful?
  - If you want to enforce that a component appears only once (like a global toast message).
  - However, a service-based approach is a better alternative.

Most of the time only selector as HTML element is used.


============================================================================================================================================

# Data binding in Angular

 Data Binding in Angular (Detailed Explanation)  

 What is Data Binding?  
- Data binding in Angular is the mechanism that synchronizes data between the  model (TypeScript code) and the  view (HTML template) . 
- It allows dynamic updates in the UI whenever the data changes in the component, and vice versa.  

This eliminates the need for  manually querying the DOM and updating elements (as done in vanilla JavaScript or jQuery).  

---

I. Why is Data Binding Needed?  
1.  Dynamic UI Updates : Automatically updates the view when the data changes.  
2.  Better Code Maintainability : No need to manually modify the DOM.  
3.  Performance Optimization : Angular’s change detection ensures efficient updates.  
4.  Two-way Communication : Allows user inputs to be reflected in the component variables.  
5.  Simplifies Complex Applications : Managing UI state across components becomes easier.  

---

II. Types of Data Binding in Angular  

Angular provides  four types of data binding:  

| Type              | Direction        | Symbol        | Use Case |
|-------------------|------------------|---------------|-----------|
|  Interpolation    | Component → View | `{{}}`        | Display dynamic values in HTML |
|  Property Binding | Component → View | `[ ]`         | Bind component properties to element attributes |
|  Event Binding    | View → Component | `( )`         | Listen to events and execute component methods |
|  Two-Way Binding  | Component ⇆ View | `[(ngModel)]` | Sync data between UI and component |

---

1. Interpolation (`{{ }}`) - One-Way Binding (Component → View)  
- Used to  display data dynamically in the template.  
- Only works with string-based values (numbers, booleans, objects must be converted to strings). 
- you can write any valid TypeScript expression inside it. 
- However, the final result must be something that can be converted to a string, because interpolation sets the text content of an HTML element.
- Angular automatically converts them to strings when using interpolation.
- Uses  double curly braces `{{ }}` to embed expressions inside HTML.  

- Example  
  Component (TypeScript) :
  export class AppComponent {
    username: string = "Anish Bhandarkar";
  }

  Template (HTML):
  <h1>Welcome, {{ username }}</h1>

  Rendered Output:
  <h1>Welcome, Anish Bhandarkar</h1>

---

2. Property Binding (`[ ]`) - One-Way Binding (Component → View)  
- Used to  bind a component property to an HTML element's property/attribute.  
- Uses  square brackets `[ ]` .  
- Unlike interpolation, it  works with all data types (numbers, booleans, objects, arrays, etc.) .  

- Example  
  Component (TypeScript):
  export class AppComponent {
    imageUrl: string = "assets/profile.jpg";
  }

  Template (HTML):
  <img [src]="imageUrl" alt="Profile Image">

  Equivalent HTML Output:
  <img src="assets/profile.jpg" alt="Profile Image">


 Difference Between Interpolation and Property Binding 
| Feature       | Interpolation (`{{}}`)    | Property Binding (`[ ]`) |
|---------------|---------------------------|----------------------|
|  Binding Type | Binds as text content     | Binds as an actual property |
|  Works With   | Only strings              | All types (booleans, numbers, objects, etc.) |
|  Use Case     | Text inside HTML elements | Dynamic attribute values (like `src`, `disabled`, `value`) |

---

 3. Event Binding (`( )`) - One-Way Binding (View → Component)  
- Used to  isten to user events (click, keypress, mouseover, input, change, etc.).  
- Uses parentheses `( )` around the event name.  
- Calls a method in the component when the event occurs.  

-Example  
 Component (TypeScript) :
  export class AppComponent {
    count: number = 0;

    increment() {
      this.count++;
    }
  }

  Template (HTML) :
  <button (click)="increment()">Click Me</button>
  <p>Count: {{ count }}</p>

-Behavior 
  - When the button is clicked, the `increment()` method runs.  
  - `count` increases and the new value is reflected in the UI.  

---

4. Two-Way Binding (`[()]`) - (Component ⇆ View)  
-  Combines Property Binding (`[ ]`) and Event Binding (`( )`) .  
- Uses  banana-in-a-box syntax `[()]`.  
- Mostly used for  form inputs (`<input>`, `<textarea>`, `<select>`, etc.).  
- Requires `FormsModule` in `app.module.ts`.  

-Example :
 Component (TypeScript): 
  export class AppComponent {
    username: string = "";
  }

  Template (HTML) :
  <input [(ngModel)]="username" placeholder="Enter your name">
  <p>Hello, {{ username }}</p>

-Behavior 
  - As the user types in the input, `username` updates in real time.  
  - The `{{ username }}` also updates dynamically.  

- Module Configuration (app.module.ts) 
  import { NgModule } from '@angular/core';
  import { FormsModule } from '@angular/forms';

  @NgModule({
    imports: [FormsModule]
  })
  export class AppModule { }


---

 Other Advanced Data Binding Techniques  

 5. Attribute Binding (`[attr.]`)  
- Binds values to HTML attributes that are not standard properties.  
- Example: `aria-label`, `data-*`, `role`, `colspan`.  

<button [attr.aria-label]="'Submit Button'">Submit</button>


 6. Class Binding (`[class.]`)  
- Dynamically applies CSS classes.  

<p [class.active]="isActive">This text changes color</p>


isActive = true;


 7. Style Binding (`[style.]`)  
- Dynamically applies inline styles.  

<p [style.color]="isRed ? 'red' : 'black'">Styled Text</p>


isRed = true;


8. bind- Syntax:
- Old syntax of alternative way of property binding.
- bind-*
- Ex:
  <img bind-src="imageUrl">
  // same as,
  <img [src]="imageUrl">


---

Summary Table  

| Type               | Syntax     | Direction        | Example |
|--------------------|------------|------------------|---------|
|  Interpolation     | `{{ }}`    | Component → View | `<p>{{ username }}</p>` |
|  Property Binding  | `[ ]`      | Component → View | `<img [src]="imageUrl">` |
|  Event Binding     | `( )`      | View → Component | `<button (click)="increment()">` |
|  Two-Way Binding   | `[()]`     | Component ⇆ View | `<input [(ngModel)]="username">` |
|  Attribute Binding | `[attr.]`  | Component → View | `<button [attr.aria-label]="'Submit'">` |
|  Class Binding     | `[class.]` | Component → View | `<p [class.active]="isActive">` |
|  Style Binding     | `[style.]` | Component → View | `<p [style.color]="'red'">` |

---

Final Thoughts  
-  Use interpolation (`{{ }}`) for inline text content.  
-  Use property binding (`[ ]`) for setting attributes dynamically.  
-  Use event binding (`( )`) for handling user interactions.  
-  Use two-way binding (`[()]`) when you need to sync user input with component variables.  


============================================================================================================================================

# Directives in Angular.
---

1. What are Directives in Angular?
Directives are special instructions in the DOM that enhance functionality by modifying elements, components, or behavior dynamically.

Angular provides three types of directives:
1. Component Directives (Technically a directive with a template)
2. Structural Directives (Modify the DOM structure)
3. Attribute Directives (Modify the appearance or behavior of elements)

---

2. Why Are Directives Needed?
- To manipulate DOM elements dynamically.
- To apply logic-based conditions for rendering elements.
- To change the appearance or behavior of elements.
- To reuse behaviors across multiple components without duplication.
- To create dynamic UI elements.

---

3. Types of Directives in Angular
(A) Component Directives
- Components are a special type of directive with a template.
- Every Angular component is a directive but with an associated HTML view (template).
- Example:
  
  import { Component } from '@angular/core';

  @Component({
    selector: 'app-example',
    template: '<h1>Hello from Component Directive!</h1>',
    styles: ['h1 { color: blue; }']
  })
  export class ExampleComponent {}
  
- Components are the most commonly used directive type.

---

(B) Structural Directives
Structural directives modify the DOM structure by adding, removing, or manipulating elements.

#Common Structural Directives
1. `*ngIf` - Adds or removes elements based on a condition.
2. `*ngFor` - Repeats an element for each item in a collection.
3. `*ngSwitch` - Conditionally renders elements based on a switch case.

#1. `*ngIf`
- Used to conditionally display elements.
- Example:
  html
  <p *ngIf="isVisible">This paragraph is conditionally visible.</p>
  
  
  isVisible = true;
  
- You can use `else`:
  html
  <p *ngIf="isVisible; else elseBlock">This is visible</p>
  <ng-template #elseBlock>
    <p>This is hidden</p>
  </ng-template>
  

#2. `*ngFor`
- Used to loop through a collection.
- Example:
  html
  <ul>
    <li *ngFor="let item of items; index as i"> {{ i }} - {{ item }}</li>
    or
    <li *ngFor="let item of items; let i = index">{{i}} - {{item}}</li>
  </ul>
  
  
  items = ['Angular', 'React', 'Vue'];

- index is a special template variable provided by *ngFor. 
- It represents the zero-based index of the current item in the items array as it is being iterated over.
  

#3. `*ngSwitch`
- Used when multiple conditions need to be checked.
- Example:
  html
  <div [ngSwitch]="fruit">
    <p *ngSwitchCase="'Apple'">🍏 Apple</p>
    <p *ngSwitchCase="'Banana'">🍌 Banana</p>
    <p *ngSwitchDefault>🥝 Unknown fruit</p>
  </div>
  
  
  fruit = 'Apple';


---

Why `ngSwitch` Uses `[ngSwitch]` Instead of `*ngSwitch`?
1. `*` (asterisk) is a shorthand for `ng-template` wrapping 
   - Structural directives like `*ngIf` and `*ngFor` add/remove entire elements dynamically.  
   - They need to wrap the entire element inside an implicit `<ng-template>`.
   - Example of `*ngIf` (expanded form):
     
     <ng-template [ngIf]="condition">
       <p>This element will be added/removed</p>
     </ng-template>
     

2. `ngSwitch` is a parent container, not a template directive 
   - `ngSwitch` does not directly add/remove elements itself.
   - Instead, it controls its child directives (`*ngSwitchCase`, `*ngSwitchDefault`), which are structural directives.
   - `ngSwitch` acts more like a controller, so it is used as `[ngSwitch]` (a property binding), not `*ngSwitch`.


- What Happens Behind the Scenes?
  - `ngSwitch` only tracks the value (`fruit`).
  - `*ngSwitchCase` and `*ngSwitchDefault` handle adding/removing elements.


- Since `ngSwitch` does not directly add/remove elements, it does not use `*`. 
- Instead, it is used as a property binding `[ngSwitch]`, while its child directives (`*ngSwitchCase`) do the actual structural manipulation.


---

(C) Attribute Directives
Attribute directives change the behavior or appearance of an element.

#Common Attribute Directives
1. `ngClass` - Adds/removes classes dynamically.
2. `ngStyle` - Applies inline styles dynamically.
3. Custom Attribute Directives - You can define your own.

#1. `ngClass`
- Used to dynamically apply classes.
- Example:
  <p [ngClass]="{active: isActive, error: hasError}">Styled Text</p>
  
  isActive = true;
  hasError = false;
  

#2. `ngStyle`
- Used to dynamically apply styles.
- Example:
  html
  <p [ngStyle]="{'color': textColor, 'font-size.px': fontSize}">Styled Text</p>
  
  
  textColor = 'blue';
  fontSize = 20;

- 2 ways:
  i. [ngStyle]="{color: 'red', 'font-size':'x-large'}">
  ii. [ngStyle]="{color: 'red', fontSize:'x-large'}">
  

#3. Custom Attribute Directive
- Example: A directive that changes background color on hover.
  
  import { Directive, ElementRef, HostListener, Renderer2 } from '@angular/core';

  @Directive({
    selector: '[appHighlight]'
  })
  export class HighlightDirective {
    constructor(private el: ElementRef, private renderer: Renderer2) {}

    @HostListener('mouseenter') onMouseEnter() {
      this.renderer.setStyle(this.el.nativeElement, 'background-color', 'yellow');
    }

    @HostListener('mouseleave') onMouseLeave() {
      this.renderer.removeStyle(this.el.nativeElement, 'background-color');
    }
  }
  
  - Usage:
    html
    <p appHighlight>Hover over me!</p>
    

---

4. Creating a Custom Directive
1. Generate a directive:
   sh
   ng generate directive myDirective
   or
   ng g d myDirective
   
2. Modify the directive (`my-directive.directive.ts`):
   
   import { Directive, ElementRef, Renderer2 } from '@angular/core';

   @Directive({
     selector: '[appMyDirective]'
   })
   export class MyDirective {
     constructor(private el: ElementRef, private renderer: Renderer2) {
       this.renderer.setStyle(this.el.nativeElement, 'color', 'red');
     }
   }

3. Register in app.module.ts declarations array
   
4. Use it:
   html
   <p appMyDirective>This text will be red.</p>
   

---

5. Understanding `@Directive` Decorator
- The `@Directive` decorator defines a directive.
- It takes a configuration object with a `selector`:
  
  @Directive({
    selector: '[appExample]'
  })
  
- Selectors are usually attribute selectors (`[appExample]`).

- Naming convention prefix(from angular.json, default is 'app') + directive name during creation

---

6. Directive Lifecycle Hooks
Like components, directives have lifecycle hooks:
| Hook              | Description |
|-------------------|------------|
| `ngOnInit`        | Runs when the directive is initialized |
| `ngOnChanges`     | Runs when input properties change |
| `ngDoCheck`       | Runs during change detection |
| `ngAfterViewInit` | Runs after child views initialize |
| `ngOnDestroy`     | Runs before the directive is destroyed |

Example:

ngOnInit() {
  console.log("Directive Initialized");
}


---

7. Directive vs. Component
| Feature             | Directive     | Component |
|---------------------|---------------|-----------|
| View (Template)     | No            | Yes |
| Use Case            | Behavior      | UI & Behavior |
| Selector Type       | `[attribute]` | `app-component` |
| Lifecycle Hooks     | Yes           | Yes |

---

8. Best Practices
- Use components over directives when a UI is needed.
- Follow naming conventions (`appHighlight`, `appMyDirective`).
- Use Renderer2 instead of direct DOM manipulation.
- Optimize change detection for performance.


---

9. How Multiple Directives Work Together

- You can apply multiple attribute directives and even mix any 1 structural directives on a single element (with some limitations).
<p appHighlight appBold [ngClass]="{'active': isActive}" *ngIf="isVisible">Styled Text</p> // correct


- Multiple Structural Directives on the Same Element (Not Allowed)
<p *ngIf="isVisible" *ngFor="let item of items">{{ item }}</p>

- Instaed use ng-container to combine multiple structural directives.:
<ng-container *ngIf="isVisible">
  <p *ngFor="let item of items">{{ item }}</p>
</ng-container>

============================================================================================================================================

# @Input() and @Output() in Angular 

- Both @Input() and @Output() are decorator functions.
- A decorator is a special type of function in TypeScript that allows modifying the behavior of a class, method, property, or accessor dynamically.
- Used for communication between a parent and child component.

- What is parent and child component?
  - If a cmponent's selector is used as an HTML element in the html of another component.
  - Child component
    @Component({
      selector: 'app-child',
      template: `<p>Received from parent: {{ data }}</p>`
    })
    export class ChildComponent {}

  - Parent component
    @Component({
      selector: 'app-parent',
      template: `<app-child></app-child>`
    })
    export class ParentComponent {}


---

1. What is @Input()? 
- `@Input()` is used to pass data from a  parent component to a  child component .

- How Does @Input() Work? 
  - It marks a  property in a child component as input.
  - The parent component can bind values to this property.

- Usage Example 
# 1. Parent to Child Data Passing 
> Child Component (child.component.ts) 

import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-child',
  template: `<p>Received from parent: {{ data }}</p>`
})
export class ChildComponent {
  @Input() data: string = '';  // Marking 'data' as an input property
}

> Parent Component (parent.component.html) 

<app-child [data]="'Hello from Parent'"></app-child>

- Here, `[data]="'Hello from Parent'"` binds the value to `@Input() data` in the child.

# 2. Using @Input with Aliases 
You can change the input property name in the child using an alias:

@Input('aliasName') data: string = '';

Now, in the parent:

<app-child [aliasName]="'Hello'"></app-child>


# 3. Using @Input with Setter 
You can use a setter function to process the data before using it:

@Input()
set data(value: string) {
  this.processedData = value.toUpperCase();
}
processedData: string = '';

---

2. What is @Output()? 
`@Output()` is used to send data  from a child component to a parent component using  EventEmitter .

How Does @Output() Work? 
- It marks a  property in a child component as an output event.
- The child component emits data when an event occurs.
- The parent listens to this event and gets the emitted value.

Usage Example 
# 1. Child to Parent Communication 
Child Component (child.component.ts) 

import { Component, Output, EventEmitter } from '@angular/core';

@Component({
  selector: 'app-child',
  template: `<button (click)="sendMessage()">Send Data</button>`
})
export class ChildComponent {
  @Output() messageEvent = new EventEmitter<string>();

  sendMessage() {
    this.messageEvent.emit('Hello from Child');
  }
}

Parent Component (parent.component.html) 

<app-child (messageEvent)="receiveMessage($event)"></app-child>
<p>Received from child: {{ childMessage }}</p>

Parent Component (parent.component.ts) 

export class ParentComponent {
  childMessage: string = '';

  receiveMessage(msg: string) {
    this.childMessage = msg;
  }
}

Here,  
- `(messageEvent)="receiveMessage($event)"` binds the child’s output event to the parent’s method.
- `this.messageEvent.emit('Hello from Child')` emits data from child to parent.

# 2. Using @Output with Aliases 

@Output('aliasName') messageEvent = new EventEmitter<string>();

Now, in the parent:

<app-child (aliasName)="receiveMessage($event)"></app-child>

---

 Key Differences Between @Input and @Output 
| Feature       | @Input()                                   | @Output() |
|---------------|--------------------------------------------|-----------|
| Purpose       | Passes data from parent to child           | Sends data from child to parent |
| Data Type     | Any (string, number, object, etc.)         | EventEmitter instance |
| Direction     | Unidirectional (Parent → Child)            | Unidirectional (Child → Parent) |
| How It Works  | Property binding `[]`                      | Event binding `()` |
| Example Usage | `<app-child [data]="'Hello'"></app-child>` | `<app-child (messageEvent)="handleEvent($event)"></app-child>` |

---

 Where Are @Input() and @Output() Used? 
 1. Reusable Components 
- Example: A  button component that gets its label via `@Input()` and emits a click event via `@Output()`.

 2. Form Components 
- Example: A  custom input field that receives a default value (`@Input()`) and emits changes (`@Output()`).

 3. Dynamic UI Components 
- Example: A  modal component where:
  - `@Input()` receives  title/content .
  - `@Output()` emits an  event when closed .

---

 When Not to Use @Input() and @Output()? 
1.  If you need shared state across multiple components  
   - Use a service with RxJS BehaviorSubject instead.
  
2.  If components are deeply nested  
   - Avoid too much `@Input()` and `@Output()` chaining.
   - Use  state management libraries (NgRx, Akita) .

3.  If the data is complex and large  
   - Consider using a service for better performance.

---

 Conclusion 
-  @Input() → Used for  parent-to-child communication.
-  @Output() → Used for  child-to-parent communication.
- They are decorator functions , modifying component properties.
-  Use them when components need to communicate without a service .

===========================================================================================================================================

# Template Reference Variables in Angular

- A template reference variable in Angular is a way to get a reference to an HTML element or an Angular component inside the template. 
- It allows direct interaction with the referenced element, component, or directive in the template without using component class properties.

---

Syntax
A template reference variable is declared using the `#` symbol, followed by a variable name.

html
<input #myInput type="text">
<button (click)="logValue(myInput.value)">Log Value</button>


In the example above:
- `#myInput` creates a reference to the `<input>` element.
- `myInput.value` is accessed inside the `(click)` event handler.

---

Why is it Used?
1. Accessing DOM elements directly
2. Interacting with child components
3. Accessing directive instances
4. Passing elements/components to methods
5. Working with forms (e.g., `ngForm`)
6. Getting reference to built-in directives like `ngTemplateOutlet`

---

Where is it Used?
Template reference variables are commonly used in:
1. Forms - To get form control values
2. Child components - To interact with child component methods and properties
3. DOM elements - For direct manipulation of native elements
4. Directives - To access instances of directives applied to elements
5. Templates & ViewContainerRef - Used with `ngTemplateOutlet` for dynamic template rendering

---

How to Use Template Reference Variables?
1. Accessing DOM Elements
You can reference an input field and use its value in an event:

html
<input #username type="text">
<button (click)="showUsername(username.value)">Show</button>



showUsername(value: string) {
  console.log(value);
}


---

2. Accessing Child Components
If you have a child component:


@Component({
  selector: 'app-child',
  template: `<p>Child Component</p>`
})
export class ChildComponent {
  greet() {
    return "Hello from Child!";
  }
}


You can access it from the parent template using a template reference variable:

html
<app-child #childComp></app-child>
<button (click)="sayHello(childComp)">Click Me</button>



sayHello(child: ChildComponent) {
  console.log(child.greet());
}


---

3. Accessing Directives
If a directive is applied to an element, you can reference its instance:


@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {
  highlight() {
    console.log("Element highlighted!");
  }
}


In the template:

html
<p appHighlight #highlightDir>Highlighted text</p>
<button (click)="highlightDir.highlight()">Highlight</button>


---

4. Using with Forms (`ngForm` & `ngModel`)
In template-driven forms, `ngForm` can be referenced using a template variable:

html
<form #userForm="ngForm" (ngSubmit)="onSubmit(userForm)">
  <input name="username" ngModel required>
  <button type="submit">Submit</button>
</form>



onSubmit(form: NgForm) {
  console.log(form.value);
}


---

5. Using with `ngTemplateOutlet` for Dynamic Templates
You can reference a `<ng-template>` and use it dynamically:

html
<ng-template #myTemplate>
  <p>This is a template</p>
</ng-template>

<div *ngIf="showTemplate">
  <ng-container *ngTemplateOutlet="myTemplate"></ng-container>
</div>


---

Scope of Template Reference Variables
Template reference variables only work inside the template they are defined in. They cannot be accessed in the component TypeScript file directly.

---

How it Differs from ViewChild?
| Feature      | Template Reference Variable       | `@ViewChild` |
|--------------|-----------------------------------|-------------|
| Access Scope | Only within the template          | Accessible in TypeScript |
| Use Case     | Simple DOM manipulation, forms    | Advanced interactions with child components |
| Syntax       | `#varName` in HTML                | `@ViewChild(Component/Directive)` in TS |
| Lifecycle    | Available in template immediately | Available after `ngAfterViewInit` |

Example:
Using `@ViewChild`:

<input type="text" #myInput value="Shatake samana">

@ViewChild('myInput') inputElement!: ElementRef;

ngAfterViewInit() {
  console.log(this.inputElement.nativeElement.value);
}


- While `#myInput` works only inside the template.
- By default when u access it using ViewChild, its value is available in ngAfterViewInit.

===========================================================================================================================================

# Why Not Use JS DOM Query Methods? instead of template variables?

- Using JavaScript DOM query methods like `document.querySelector()` or `document.getElementById()` might seem like an alternative to template reference variables (`#var`), 
  but Angular encourages using template reference variables for several reasons.

---

Why Not Use JS DOM Query Methods?
1. Not Angular-friendly (Bypasses Angular's Rendering Cycle)
   - Angular has its own rendering and change detection system. 
   - Directly querying the DOM bypasses it, which can lead to inconsistencies and unexpected behaviors.
   - Example:
     
     document.querySelector('input').value = 'New Value';
     
     If Angular updates the value later, your change might be overridden.

2. Not Scoped to the Component
   - `document.querySelector()` and similar methods operate on the entire document, meaning:
     - If you have multiple instances of the same component, these queries might select the wrong element.
     - There's a risk of affecting unintended elements.

3. Does Not Work Well with Dynamic Elements
   - If an element is added or removed dynamically (e.g., using `*ngIf`), the reference might be invalid.
   - Template reference variables automatically update with the view lifecycle.

4. Performance Overhead
   - DOM queries (`querySelector`, `getElementById`) require searching the entire DOM tree, which can be slow, especially for large applications.
   - Angular's template reference variables do not perform global DOM searches, making them more efficient.

5. Harder to Maintain and Debug
   - Using `#var` makes it clear which elements are referenced, making the template easier to read.
   - Using `document.querySelector()` scatters logic across multiple places, making maintenance harder.

---

When Can You Use DOM Methods?
1. When dealing with third-party libraries that manipulate the DOM (e.g., jQuery, Leaflet maps).
2. When accessing global elements, such as `document.body` or `window`.

---

Better Alternative: `@ViewChild`
If you need to access an element in the TypeScript file, `@ViewChild` is a better alternative to `document.querySelector()`.


@ViewChild('myInput') inputRef!: ElementRef;

ngAfterViewInit() {
  this.inputRef.nativeElement.value = 'Updated by ViewChild';
}


This ensures that:
- The reference is scoped to the component.
- It updates when the view is initialized.

===========================================================================================================================================

# How `document.querySelector()` Works in an Angular Application

- `document.querySelector()` is a native JavaScript method, which means it does not respect Angular’s component boundaries.
- It scans the entire DOM tree starting from `document`, not just the component where it's called.
- This means if multiple components have similar elements (e.g., multiple `<input>` fields), `querySelector()` might select the first matching elementin the whole document, even if it's from a different component.

- i.e If in a page there are multiple components and from 1 of the component if i do doc.querySe..() then it searchs all components in that page instead of the component from where i wrote doc.querySe..()

#Example: Searching the Whole Document

@Component({
  selector: 'app-child',
  template: `<input type="text" value="Child Component">`
})
export class ChildComponent implements AfterViewInit {
  ngAfterViewInit() {
    const input = document.querySelector('input'); // Selects the first <input> in the entire page!
    console.log(input?.value); // Might log an input from a different component!
  }
}

- If another component has an `<input>`, `document.querySelector('input')` might select that one instead of the local one.

---

How to Search Only Within a Specific Component?
#1️⃣ Use `this.elementRef.nativeElement.querySelector()`
Instead of `document.querySelector()`, use Angular's `ElementRef` to limit the search to the current component only.


import { Component, ElementRef, AfterViewInit } from '@angular/core';

@Component({
  selector: 'app-child',
  template: `<input type="text" value="Child Component">`
})
export class ChildComponent implements AfterViewInit {
  constructor(private elRef: ElementRef) {}

  ngAfterViewInit() {
    const input = this.elRef.nativeElement.querySelector('input');
    console.log(input?.value); // Selects only the input within this component
  }
}

✅ This ensures only elements inside this component'sDOM are selected.

---

#2️⃣ Use `@ViewChild()` (Preferred in Angular)
Instead of querying manually, use Angular’s `@ViewChild()`:


import { Component, ViewChild, ElementRef, AfterViewInit } from '@angular/core';

@Component({
  selector: 'app-child',
  template: `<input #myInput type="text" value="Child Component">`
})
export class ChildComponent implements AfterViewInit {
  @ViewChild('myInput') inputRef!: ElementRef;

  ngAfterViewInit() {
    console.log(this.inputRef.nativeElement.value); // Works within the component scope
  }
}

✅ This is faster and safersince Angular manages it internally.

---

Final Conclusion
| Method                                     | Scope                                 | Works in Angular Lifecycle?| Performance|
|--------------------------------------------|---------------------------------------|--------|----------------|
| `document.querySelector()`                 | Searches the whole page               | ❌ No  | 🚫 Slower (global search) |
| `this.elRef.nativeElement.querySelector()` | Searches only inside the component    | ✅ Yes | ✅ Faster (local search) |
| `@ViewChild()`                             | Direct reference inside the component | ✅ Yes | 🚀 Best performance |

- Avoid `document.querySelector()` unless absolutely necessary.
- It can cause unexpected behavior in an Angular app with multiple components. 
- Instead, use `@ViewChild()` or `ElementRef` for better performance and scoping.

===========================================================================================================================================

# @ViewChild & @ViewChildren in Angular

- Both `@ViewChild` and `@ViewChildren` are decorators used in Angular to get a reference to elements, components, or directives in the view (DOM) of the current component. 
- They are commonly used to interact with child elements programmatically.

---

1️. @ViewChild()
`@ViewChild` is used to get a reference to a single element, component, or directive within the template.

Syntax:
@ViewChild(selector, { static: boolean }) variableName!: Type; // static - false by default.

- selector → The reference name (`#var`), component class, directive class, or a template reference variable.
- static (optional) → Determines when the reference is available (during `ngOnInit` or after `ngAfterViewInit`).
- variableName → The local variable in the component to store the reference.
- Type → The type of the referenced element (e.g., `ElementRef`, component, directive).

---

Example 1: Accessing an HTML Element
html
<input #myInput type="text" value="Hello">
<button (click)="changeValue()">Change Value</button>


import { Component, ViewChild, ElementRef, AfterViewInit } from '@angular/core';

@Component({
  selector: 'app-demo',
  templateUrl: './demo.component.html',
})
export class DemoComponent implements AfterViewInit {
  @ViewChild('myInput') inputRef!: ElementRef;

  ngAfterViewInit() {
    console.log(this.inputRef.nativeElement.value); // Logs "Hello"
  }

  changeValue() {
    this.inputRef.nativeElement.value = "Updated!";
  }
}

✅ Why Use `@ViewChild` Here?
- Directly manipulates the DOM inside the component.
- More efficient than `document.querySelector()`.

---

Example 2: Accessing a Child Component
#Child Component

@Component({
  selector: 'app-child',
  template: `<p>Child Component</p>`
})
export class ChildComponent {
  sayHello() {
    return "Hello from Child!";
  }
}

#Parent Component
html
<app-child #childComp></app-child>
<button (click)="callChildMethod()">Call Child Method</button>


import { Component, ViewChild, AfterViewInit } from '@angular/core';
import { ChildComponent } from './child.component';

@Component({
  selector: 'app-parent',
  templateUrl: './parent.component.html',
})
export class ParentComponent implements AfterViewInit {
  @ViewChild('childComp') child!: ChildComponent;

  ngAfterViewInit() {
    console.log(this.child.sayHello()); // Logs: "Hello from Child!"
  }

  callChildMethod() {
    alert(this.child.sayHello());
  }
}

✅ Why Use `@ViewChild` Here?
- Allows direct access to child component methods and properties.
- Useful when child components don’t need to notify the parent.

---

When to Set `static: true` or `static: false`?
| Value             | When Available?        | Use Case |
|-------------------|------------------------|--------------|
| `true`            | In `ngOnInit()`        | When the element/component is not dynamically added (e.g., always present in the template). |
| `false` (default) | In `ngAfterViewInit()` | When the element/component might be dynamically added or removed (e.g., inside `*ngIf`). |

✅ Example where `static: true` is needed:
html
<input #myInput *ngIf="showInput">


@ViewChild('myInput', { static: true }) inputRef!: ElementRef;
ngOnInit() {
  console.log(this.inputRef.nativeElement); // Works because static: true
}

- In short if u want to access it within ngOnInit, set static to true.


---

2. @ViewChildren()
`@ViewChildren` is used when you need to get multiple instances of elements, components, or directives.

Syntax:
@ViewChildren(selector) variableName!: QueryList<Type>;

- Returns a QueryList, which is similar to an array but is reactive and updates when the view changes.

---

Example: Accessing Multiple Elements
html
<p #para>First Paragraph</p>
<p #para>Second Paragraph</p>
<button (click)="logTexts()">Log Texts</button>


import { Component, ViewChildren, QueryList, ElementRef, AfterViewInit } from '@angular/core';

@Component({
  selector: 'app-demo',
  templateUrl: './demo.component.html',
})
export class DemoComponent implements AfterViewInit {
  @ViewChildren('para') paragraphs!: QueryList<ElementRef>;

  ngAfterViewInit() {
    this.logTexts();
  }

  logTexts() {
    this.paragraphs.forEach((p) => console.log(p.nativeElement.textContent));
  }
}

✅ Why Use `@ViewChildren` Here?
- `@ViewChild` only selects one element, but `@ViewChildren` retrieves all matching elements.

---

Example: Accessing Multiple Child Components
#Child Component

@Component({
  selector: 'app-child',
  template: `<p>Child Component</p>`
})
export class ChildComponent {
  greet() {
    return "Hello from Child!";
  }
}

#Parent Component
html
<app-child></app-child>
<app-child></app-child>
<app-child></app-child>
<button (click)="callAllChildren()">Call All</button>


import { Component, ViewChildren, QueryList, AfterViewInit } from '@angular/core';
import { ChildComponent } from './child.component';

@Component({
  selector: 'app-parent',
  templateUrl: './parent.component.html',
})
export class ParentComponent implements AfterViewInit {
  @ViewChildren(ChildComponent) children!: QueryList<ChildComponent>;

  ngAfterViewInit() {
    this.callAllChildren();
  }

  callAllChildren() {
    this.children.forEach(child => console.log(child.greet()));
  }
}

✅ Why Use `@ViewChildren` Here?
- Allows accessing all instances of a component.
- Useful for managing multiple child components dynamically.

---

Key Differences Between `@ViewChild` and `@ViewChildren`
| Feature      | `@ViewChild`                         | `@ViewChildren` |
|--------------|--------------------------------------|----------------|
| Returns      | A single reference                   | A `QueryList` (like an array) |
| Selects      | First matching element/component     | All matching elements/components |
| Use Case     | When interacting with a single child | When interacting with multiple children |
| Available in | `ngAfterViewInit()`                  | `ngAfterViewInit()` |
| Performance  | More efficient for single elements   | Used for bulk operations |

---

Final Thoughts
- Use `@ViewChild` when working with a single element or component.
- Use `@ViewChildren` when working with multiple elements or components.
- Avoid `document.querySelector()`; use these Angular mechanisms for better performance and maintainability.

===========================================================================================================================================




































// TODO:
1) Demonstrate how angular is SPA?
2) IN Angular 14+ (17) modules are not used. How to use standalone comp? Command to use modules in Ang 17 ... (Refer temp.txt)