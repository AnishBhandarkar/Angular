Table of Contents:
# API vs. Framework vs. Library
# What is Angular? 
# React vs. Angular
# Inversion of Control (IOC)
# Installation
# Node.js  vs. nvm vs. npm
# Creating new Angular project
# Introduction about build
# Just in Time vs. Ahead of Time compilation
# Creating a project
# How Angular app runs?
# What is SPA? (Single Page Application)

# ng serve vs. ng build:
# Modules in angular
# Components in angular




# API vs. Framework vs. Library
--------------------------------
1) API:
> A set of rules and protocols that allow different software components to communicate.
> Defines how software interacts with external services or components.
> Example: REST API (e.g., GitHub API, Twitter API) lets you fetch or modify data.
> Think of an API as a menu in a restaurant – it tells you what you can order but doesn’t tell you how the food is prepared.

2) Library:
> A collection of pre-written code that you can call and use in your application to simplify development.
> You call functions from the library when needed.
> Example: Lodash (JavaScript utility functions), NumPy (Python for numerical operations), jQuery (DOM manipulation), React
> Think of a library as a toolbox – you pick and use the tools (functions) as required.


3) Framework:
> A structured environment that dictates how you should organize and build your application.
> It calls your code and provides a set of rules and conventions (Inversion of Control).
> Example: Angular (Complete front-end framework), Spring Boot (Java back-end framework), Django (Python web framework)
> Think of Angular as a full construction kit —it provides everything.

===========================================================================================================================================

# What is Angular?
--------------------------------
> Angular is a web framework that empowers developers to build fast, reliable applications.
> It is maintained by a dedicated team at Google.
> Angular provides a broad suite of tools, APIs, and libraries to simplify and streamline the development workflow. 
> Angular gives you a solid platform on which to build fast, reliable applications that scale with both the size of the team and the size of the codebase.

===========================================================================================================================================

# React vs. Angular
--------------------------------
Great question! In JavaScript, the distinction between API, Library, and Framework becomes clearer when looking at React and Angular:

React (Library) vs. Angular (Framework)

| Feature            | React (Library) | Angular (Framework) |
|--------------------|-------------------|-----------------------|
| Definition      | A UI library focused on building components | A full-fledged framework for building web apps |
| Control Flow   | You call React functions (`useState`, `useEffect`) | Angular dictates the app structure and calls your code |
| Opinionated?   | No, you choose your tools (e.g., state management, routing) | Yes, Angular provides built-in solutions (RxJS, Forms, Router) |
| Flexibility    | High—you can use React with any backend, state manager, etc. | Lower—you follow Angular's structure and use its modules |
| Inversion of Control (IoC) | No (you control the flow) | Yes (Angular manages component lifecycle) |

===========================================================================================================================================

# Inversion of Control (IOC):
------------------------------
> IOC is a design principle where the control of program flow is shifted from your code to an external system (like a framework). 
> Instead of you calling functions, the framework calls your code when needed.


Example in JavaScript: IoC vs. No IoC

i)Without IoC (You Control the Flow)
In a normal library, you call functions when needed:

// Example using a library (React)
function fetchData() {
  console.log("Fetching data...");
}

fetchData(); // You explicitly call the function
you are in control—you decide when to call fetchData().


ii) With IoC (Framework Controls the Flow)
In a framework, it calls your code when required, following its rules:

// Example in Angular (Framework)
@Component({
  selector: 'app-example',
  template: '<p>Example</p>'
})
export class ExampleComponent implements OnInit {
  ngOnInit() {
    console.log("Component initialized!"); // Angular calls this method
  }
}

Here, Angular controls the lifecycle—it calls `ngOnInit()` when the component initializes.

===========================================================================================================================================

# Installation
-----------------
> Node js should be there.
> "npm install -g @angular/cli" in cmd.

> Checking version:
  node -v
  npm -v
  ng -v
  
===========================================================================================================================================

# Node.js  vs. nvm vs. npm
---------------------------
1) Node.js
- What is it?
  - A JavaScript runtime that allows you to run JavaScript outside the browser.
  - Comes with built-in modules for file system operations, HTTP servers, etc.

- Key Features:
  - Runs JavaScript on the backend.
  - Uses the V8 engine (same as Chrome).
  - Supports asynchronous programming.

- Command to Check Version: 
  node -v
  
- Example Use:
  console.log("Hello from Node.js!");

  Run it with: node script.js

---

2) NVM (Node Version Manager)
- What is it?
  - A tool to manage multiple versions of Node.js on your system.

- Key Features:
  - Easily switch between Node versions.
  - Install/update Node.js without affecting global settings.
  
- Commands:
  - Install a specific Node version:  
    nvm install 18

  - Use a specific version:  
    nvm use 16

  - List installed versions:  
    nvm list

- Think of NVM as a Node.js version switcher—use different versions for different projects.

---

3) NPM (Node Package Manager)
- What is it?
  - A package manager that comes with Node.js.

- Key Features:
  - Installs and manages JavaScript libraries and dependencies.
  - Uses a package.json file to track project dependencies.

- Commands:
  - Check version:
    npm -v
	
  - Install a package globally:
    npm install -g @angular/cli

  - Install project dependencies:  
    npm install

- Think of NPM as a marketplace for JavaScript libraries—it lets you install and manage packages.

===========================================================================================================================================

# Creating new Angular project
- ng new proj-name

- You'll be asked some configuration questions:
  - Would you like to add Angular routing? → Yes/No
  - Which stylesheet format would you like to use? → Choose CSS, SCSS, LESS, etc.
  
- Move into the project folder:
cd proj-name

- Start the development server:
ng serve

- or specify a port:
ng serve --port 4201

- Starts the Angular development server and automatically opens the app in the default web browser.
ng serve --open (Shorthand: ng s -o)


- Build the Angular Project
To create a production build: ng build --prod
This generates optimized files inside the dist/ folder.

===========================================================================================================================================

# Introduction about build
---------------------------
> In Angular (or any frontend framework), "build" refers to the process of converting your source code into an optimized format that browsers can understand. 
> This includes compiling TypeScript, bundling files, minifying, and optimizing performance.  

-Why Is "Build" Needed? 
- Browsers don’t understand TypeScript → It must be converted to JavaScript.  
- Angular uses modules and components → They must be bundled into fewer files.  
- Performance optimization → Reduces file size, removes unused code, and speeds up execution.  
- Security → Hides the original source code to prevent direct modification.  


-What Does the Build Contain?
When you run:  ng build --configuration=production
It generates a /dist/ (distribution) folder containing optimized files like:

| File | Purpose |
|------|---------|
| `index.html`   | The main HTML file that loads the app |
| `main.js`      | Compiled JavaScript from your Angular components |
| `runtime.js`   | Bootstraps the Angular app |
| `polyfills.js` | Ensures compatibility with older browsers |
| `styles.css`   | Minified global styles |
| `assets/`      | Static files like images and fonts |
-----------------

-Development vs. Production Build 
| Feature            | `ng serve` (Dev Mode)     | `ng build --prod` (Prod Mode)    |
|--------------------|---------------------------|----------------------------------|
| Optimization   | No                        | Yes (minification, tree-shaking) |
| File Size      | Large                     | Small                            |
| Debugging      | Easier (with source maps) | Harder (obfuscated code)         |
| Performance    | Slower 					 | Faster                           |
| Error Handling | More logging              | Less logging (for security)      |

===========================================================================================================================================

# Just in Time vs. Ahead of Time compilation:
---------------------------------------------
Both JIT (Just-in-Time) and AOT (Ahead-of-Time) involve compilation, but they differ in 'when' and 'how' the compilation happens.

1) JIT Compilation (Just-in-Time)
- When does it happen? 
  JIT compiles the Angular templates at runtime, i.e., when the application is being loaded in the browser.
  
- How does it work?
  1. Angular loads the app's JavaScript (including components, services, etc.).
  2. The Angular compiler runs in the browser and compiles the templates and components into executable code.
  3. Only then does the app start rendering in the browser.

- Impact: Since the compilation happens in the browser during runtime, the initial loading of the app can be slower, and the bundle size is larger because the compiler is included.

---

2) AOT Compilation (Ahead-of-Time)
- When does it happen?
  AOT compiles the Angular templates before the app is run (i.e., at build time, during the ng build process).

- How does it work? 
  1. The Angular compiler is run during the build to pre-compile the TypeScript templates and HTML into optimized JavaScript code.
  2. The compiled templates are included directly in the final bundle, which is served to the browser.
  3. Since the templates are already compiled, the browser doesn't need to run the Angular compiler during execution.

- Impact: AOT results in a smaller and faster app because there's no need for the Angular compiler at runtime, and the browser only receives the already compiled code.

---
Key Difference:
- JIT compiles templates in the browser when the app is loaded.
- AOT compiles templates before the app is served, producing optimized code.

- Why Does AOT Improve Performance?
	- Smaller Bundle: Since templates are precompiled, no need to send the compiler code to the browser.
	- Faster Execution: Precompiled templates are ready to be executed by the browser directly, reducing the time spent compiling in the browser.
	- Early Error Detection: AOT can catch template errors during the build, helping to avoid runtime errors.

===========================================================================================================================================

# Creating a project:
ng new Proj-name

This will create following folder structure.

> .angular
> node_modules
> src
	> app
		> app-routing.module.ts
		> app.module.ts
		> app.component.html
		> app.component.scss
		> app.component.ts
		> app.component.spec.ts
	
	> assets
		> .gitkeep
		
	> environments
		> environment.ts
		> environment.prod.ts
	
	> favicon.ico
	> index.html
	> main.ts
	> polyfills.ts
	> styles.css
	> test.ts

> .browserslistrc
> .editorconfig
> .gitignore
> angular.json
> karma.conf.js
> package-lock.json
> package.json
> README.md
> tsconfig.app.json
> tsconfig.json
> tsconfig.spec.json


Functinalities of each file are as follows:

> `.angular/`
- This is a cache folder used by the Angular CLI to store temporary build artifacts.
- It speeds up builds by caching intermediate results.
- You can delete this folder safely; Angular will regenerate it when needed.

> `node_modules/`
- Contains all the installed dependencies (packages) listed in `package.json`.
- This folder is created after running `npm install`.
- It includes Angular itself, third-party libraries, and build tools.

> `src/`
- The main source folder where the actual application code resides.
- Contains the `app/`, `assets/`, and `environments/` folders, along with important configuration files.

> `src/app/`
- This folder contains the root application module (`app.module.ts`) and the main component (`app.component.ts`).
- Additional components, services, and modules are typically created inside this folder.

> `src/app/app-routing.module.ts`
- Defines the application's routes using the Angular Router.
- Used to configure navigation between different components/pages.

> `src/app/app.module.ts`
- The root module of the application.
- Declares components, imports necessary Angular modules, and configures services.
- Every Angular application must have at least one module (usually `AppModule`).

> `src/app/app.component.ts`
- The main component of the application (bootstrapped in `app.module.ts`).
- Defines the logic for the root component.

> `src/app/app.component.html`
- The template file (UI) for the `AppComponent`.

> `src/app/app.component.scss`
- The styles specific to `AppComponent` (written in SCSS, but can be changed to CSS).

> `src/app/app.component.spec.ts`
- The unit test file for `AppComponent`.
- Uses Jasmine for testing.

> `src/assets/`
- This folder is used for storing static assets like images, fonts, and JSON files.
- The `assets/` folder is copied to the `dist/` folder when you build the project.

> `src/assets/.gitkeep`
- An empty file used to ensure the `assets/` folder is tracked in Git (Git does not track empty folders).

> `src/environments/`
- Contains environment-specific configuration files.

> `src/environments/environment.ts`
- Contains settings for the development environment.

> `src/environments/environment.prod.ts`
- Contains settings for the production environment.
- Used when running `ng build --prod`.

> `src/favicon.ico`
- The favicon (icon shown in the browser tab).

> `src/index.html`
- The main HTML file that loads the Angular app.
- Contains a `<body>` tag where `AppComponent` is inserted.

> `src/main.ts`
- The entry point of the application.
- Bootstraps the `AppModule` and starts the Angular app.

> `src/polyfills.ts`
- Includes necessary polyfills to support older browsers.

> `src/styles.css`
- The global stylesheet for the application.

> `src/test.ts`
- Configures unit testing using Karma.

---

> `.browserslistrc`
- Specifies which browsers the application should support.
- Used by tools like Autoprefixer and Babel.

> `.editorconfig`
- Defines coding style guidelines (like indentation and line endings).
- Helps maintain consistency across different code editors.

> `.gitignore`
- Specifies which files and folders should be ignored by Git.
- Commonly ignores `node_modules/`, `dist/`, and other unnecessary files.

> `angular.json`
- The main configuration file for the Angular CLI.
- Defines build options, assets, styles, scripts, and environment settings.

> `karma.conf.js`
- The configuration file for Karma, which runs unit tests.

> `package-lock.json`
- Automatically generated when dependencies are installed.
- Ensures that the exact dependency versions are used in all installations.

> `package.json`
- Contains project metadata and lists dependencies.
- Defines scripts like `ng serve`, `ng build`, and `ng test`.

> `README.md`
- A documentation file containing information about the project.
- Typically includes setup instructions.

> `tsconfig.app.json`
- TypeScript configuration file specifically for the Angular application.

> `tsconfig.json`
- The global TypeScript configuration file.
- Defines TypeScript compiler options.

> `tsconfig.spec.json`
- TypeScript configuration for test files.

===========================================================================================================================================

# How Angular app runs?

1. Entry Point - `main.ts`
-------------------------------
When you run `ng serve`, `ng build`, or `ng start`, Angular starts execution from `src/main.ts`, which is the main entry point of the application.  

Inside `main.ts`: 
import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
import { AppModule } from './app/app.module';

platformBrowserDynamic().bootstrapModule(AppModule)
  .catch(err => console.error(err));


What happens here:  
- `platformBrowserDynamic()` creates a dynamic platform for running Angular applications in the browser. It returns an instance of PlatformRef,
   which is a reference to the Angular platform. It provides methods to bootstrap modules, destroy the platform, and access the injector.
- `.bootstrapModule(AppModule)` loads the `AppModule`, the root module of the application. And this method returns a promise.
- `.catch(err => console.error(err))` catches any errors during the bootstrapping process.  



2. Bootstrapping `AppModule`  
-----------------------------
Angular loads the `AppModule`, which is the root module of the application.  

Inside `app.module.ts`:
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';

@NgModule({
  declarations: [AppComponent], 
  imports: [BrowserModule], 
  bootstrap: [AppComponent] 
})
export class AppModule { }


What happens here:  
- `@NgModule` decorator marks this as an Angular module.  
- `declarations` registers components, directives, and pipes.  
- `imports` loads required modules like `BrowserModule`, which is needed to run an Angular app in a browser.  
- `bootstrap` specifies `AppComponent` as the starting component.  



3. Root Component Initialization  
----------------------------------
Once `AppModule` is loaded, Angular initializes `AppComponent`, which serves as the root component of the application.  

Inside `app.component.ts`:
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss']
})
export class AppComponent {
  title = 'Practice';
}

What happens here:  
- `@Component` decorator marks this as an Angular component defines metadata for `AppComponent`.  
- `selector: 'app-root'` means Angular will replace `<app-root></app-root>` with this component’s HTML.  


4. `index.html` Loads the Root Component  
---------------------------------------
The `index.html` file in `src` acts as the main container for the Angular app.  

Inside `index.html`:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Practice</title>
</head>
<body>
  <app-root></app-root> <!-- This will be replaced with AppComponent -->
</body>
</html>

What happens here:  
- The `<app-root>` tag is a placeholder.  
- When Angular starts, it replaces `<app-root>` with `AppComponent`'s HTML.  



5. Rendering and Change Detection  
----------------------------------
- Angular compiles the templates using JIT (Just-in-Time) in development or AOT (Ahead-of-Time) in production.  
- The rendered HTML is inserted into `index.html`.  
- Change detection ensures that UI updates happen whenever the component’s data changes.  


Summary of the Angular Startup Flow  
---------------------------------------
1. `main.ts` starts the application and calls `bootstrapModule(AppModule)`.  
2. `AppModule` loads all necessary components and dependencies.  
3. `AppComponent` is bootstrapped as the main component.  
4. `index.html` contains the `<app-root>` tag, which Angular replaces with `AppComponent`'s content.  
5.  Angular compiles templates, initializes components, and sets up change detection.  

============================================================================================================================================

# What is SPA? (Single Page Application)

> A Single Page Application (SPA) is a type of web application that loads a single HTML page and dynamically updates the content without reloading the entire page. 
> Angular is designed for building SPAs.


How does an Angular SPA work?
-----------------------------
i) Bootstraps the Angular app:
platformBrowserDynamic() initializes Angular and loads the root module (AppModule).
This ensures that the entire application runs within a single HTML page (index.html).

ii) Router manages navigation without page reloads:
In a traditional multi-page app, every user action (e.g., clicking a link) triggers a full-page reload.
In an SPA, Angular’s Router Module intercepts navigation and updates only the necessary parts of the page.

iii) Dynamically updates the DOM
Instead of fetching new HTML files from the server, Angular modifies the existing page using JavaScript.


How Components are Stored and Rendered in Angular?
-----------------------------------------------------
1️) At the start (ng serve or ng build)
> Angular compiles all components (.ts, .html, .css) into optimized JavaScript files.
> These files are loaded into the browser when the application first starts.
> The browser does not need to request new HTML files from the server.

2️) When navigating between pages
> Angular does not reload the page.
> Instead, it removes the old component from the DOM and inserts the new component inside <router-outlet>.
> The JavaScript in memory handles this transition without contacting the server.

> The server is only contacted once unless you refresh or fetch new data via an API.



============================================================================================================================================

# ng serve vs. ng build:

- When we deploy app to browser via any of above methods, after compilation, the main.js file,
  which contains all of the app's optimized code, polyfill.js, styles.css all are injected
  into index.html.
- Ex:
<!doctype html>
  <html lang="en">
    <head>
      ...
      <link rel="icon" type="image/x-icon" href="favicon.ico">
      <link rel="stylesheet" href="styles.css"></head>
    <body>
      <app-root></app-root>
      <script src="polyfills.js" type="module">
      </script><script src="main.js" type="module"></script>
    </body>
  </html>

1. ng serve: (For Development)
- Compiles the Angular application in memory without writing files to the disk.
- When you run ng serve, the Angular CLI compiles the application in-memory using Webpack's Dev Server.
- The compiled files (HTML, CSS, JS) are not written to disk (i.e., not stored in the dist/ folder).
- Instead, they are stored temporarily in RAM and served directly from there.
- This makes hot-reloading faster because there’s no need to read/write files on disk.
- The .angular folder is stored on disk, but it mostly contains build cache and incremental compilation data.
- This helps speed up subsequent ng serve runs, but it is not the actual compiled output.
- ng serve Serves the application at http://localhost:4200/ by default.
- It automatically reloads the page when files are modified.
- When to use it:
  - During development when you need live reloading and fast iterations.
  - When testing your app locally without worrying about deployment.
- When we do ng serve, JIT compilation occurs and code minification is minimal not complete minification.


2. ng build: (For Production/Deployment)
- Compiles the Angular app into static files (HTML, CSS, JS, assets).
- Generates output in the dist/ folder stored in disk.
- Uses ahead-of-time (AOT) compilation to optimize performance.
- Minifies and optimizes files.
- When to use it:
  - When you need to deploy the app to a server or cloud hosting.
  - When you need an optimized build for better performance.
- Does NOT serve the app (you need an external server like http-server, Nginx, Apache, or Firebase Hosting).
- To deploy that build in browser we can use http-server.
  - npm install -g http-server
  - Go to dist/ directory where html, js files are there.
  - http-server -p 4200 // Will start the server.





| Feature               | `ng serve`                               | `ng build` |
|-----------------------|------------------------------------------|-----------------------|
| Purpose               | Development (Live Preview)               | Production (Deployment) |
| Creates `dist/`?      |  No                                      |  Yes |
| Hot Reloading?        |  Yes                                     |  No |
| Optimized Code?       |  No                                      |  Yes |
| Server Required?      |  No (uses Webpack Dev Server)            |  Yes (e.g., `http-server`, Nginx) |
| Minification          |  No (only bundling & some optimizations) |  Yes (fully minified using Terser) |
| Tree Shaking          |  Partial                                 |  Full tree shaking  |
| Dead Code Elimination |  No                                      |  Yes |
| Source Maps           |  Enabled (for debugging)                 |  Disabled (unless manually enabled) |
| File Compression      |  No                                      |  Yes  |


Note:
-----
- When you run the ng build (build only) or ng serve (build and serve locally) CLI commands, the type of compilation (JIT or AOT) depends on the value of the aot property in your build configuration specified in angular.json. 
- By default, aot is set to true for new CLI applications.
- If its not set, then serve-jit, build-aot.

============================================================================================================================================


# Modules in angular.
- Angular modules help organize and manage different parts of an application.
- They group related components, directives, pipes, and services, making the app scalable, maintainable, and modular.

- Creating a feature module via CLI: 
ng g m module-name

- Creating component within a feature module via CLI:
ng g c module-name/component-name

---

1. What is an Angular Module?
An Angular module is a container for a set of related functionality in an Angular application. 

It helps:
- Organize code by grouping related components, services, and directives.
- Improve performanceby enabling lazy loading of features.
- Manage dependencies efficiently.

- Syntax: Creating a Module
  - Modules are created using the `@NgModule` decorator.

  -Ex:
    import { NgModule } from '@angular/core';
    import { BrowserModule } from '@angular/platform-browser';
    import { AppComponent } from './app.component';

    @NgModule({
      declarations: [AppComponent], // Components, Directives, Pipes
      imports: [BrowserModule], // Import other modules
      providers: [], // Services
      exports: [UserComponent] // Export the component to be used outside module.
      bootstrap: [AppComponent] // Root component
    })
    export class AppModule {}


---

2. Why are Angular Modules Used?
1. Code Organization– Groups related features together.
2. Scalability– Helps build large applications in a modular way.
3. Reusability– Feature modules can be reused across different applications.
4. Lazy Loading– Improves performance by loading modules only when needed.
5. Dependency Management– Handles service providers efficiently.

---

3. Types of Angular Modules
Angular has different types of modules, each serving a specific purpose.

1️⃣ Root Module (`AppModule`)
- The main module that bootstraps the Angular app.
- Declared in `app.module.ts`.


@NgModule({
  bootstrap: [AppComponent]
})
export class AppModule {}


---

2️⃣ Feature Modules
- Used to organize specific functionality.
- Example: A `UserModule` for user-related components.


@NgModule({
  declarations: [UserComponent],
  imports: [CommonModule],
  exports: [UserComponent]
})
export class UserModule {}


Then, import it into `AppModule`:

import { UserModule } from './user/user.module';

@NgModule({
  imports: [UserModule]
})
export class AppModule {}


---

3️⃣ Shared Module
- Contains reusable components, directives, and pipes.
- Prevents duplication across modules.


@NgModule({
  declarations: [SharedComponent],
  exports: [SharedComponent]
})
export class SharedModule {}


Then, import it into other modules:

import { SharedModule } from '../shared/shared.module';

@NgModule({
  imports: [SharedModule]
})
export class FeatureModule {}


---

4️⃣ Core Module
- Holds singleton services (e.g., authentication, API calls).
- Prevents re-importing services in multiple places.


@NgModule({
  providers: [AuthService]
})
export class CoreModule {}


Import in `AppModule`:

import { CoreModule } from './core/core.module';

@NgModule({
  imports: [CoreModule]
})
export class AppModule {}


---

5️⃣ Routing Module
- Manages application routes.
- Example: `AppRoutingModule` to define all app routes.
- app-routing.module.ts


import { RouterModule, Routes } from '@angular/router';

const routes: Routes = [
  { path: 'home', component: HomeComponent },
  { path: '', redirectTo: 'home' } // Wildcard route
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule {}


---

6️⃣ Lazy-Loaded Module
- Improves performance by loading modules only when needed.


const routes: Routes = [
  { path: 'dashboard', loadChildren: () => import('./dashboard/dashboard.module').then(m => m.DashboardModule) }
];


- `DashboardModule` will only be loaded when the user visits `/dashboard`.

---

4. Advantages of Angular Modules
 Code Organization– Keeps the application structured and maintainable.  
 Reusability– Shared modules reduce duplicate code.  
 Performance Optimization– Lazy loading speeds up initial loading.  
 Separation of Concerns– Each module handles a specific part of the app.  
 Easier Testing– Modules allow for isolated unit testing.  

---

5. Disadvantages of Angular Modules
 Overhead in Small Projects– For very small apps, modules can feel unnecessary.  
 Complexity in Large Apps– Managing multiple modules can become difficult.  
 Extra Configuration Needed– Routing, providers, and lazy loading require setup.  

---

6. Angular Standalone Components (No Modules)
Since Angular 14+, you can build apps without NgModules using Standalone Components.


import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from './app.component';

bootstrapApplication(AppComponent);


- Advantages of Standalone Components:
  - No need to define `NgModule`.
  - Reduces boilerplate.
  - Works well for smaller applications.


- Why NgModules Removed in Angular 14+?
  - Prevents Tree Shaking – Imports the entire module, even if only a few components/services are used.
  - Increases Bundle Size – Unused components/directives remain in the final build.
  - Complex Dependency Management – Providers in NgModule can create unnecessary dependencies.
  - Eager Loading Issues – If a module is imported in AppModule, it gets loaded even if not needed.
  - Extra Boilerplate Code – Developers must declare, import, and export components manually.
  - Slower Initial Loading – Modules increase the initial JavaScript bundle size.

---

7. Summary
| Module Type              | Purpose |
|--------------------------|------------------------------------------------|
| Root Module (`AppModule`)| Bootstraps the app |
| Feature Module           | Groups related functionality |
| Shared Module            | Contains reusable components/pipes/directives |
| Core Module              | Stores singleton services like authentication |
| Routing Module           | Handles application routing |
| Lazy-Loaded Module       | Loads modules only when required for performance |


============================================================================================================================================

# Components in angular

- A Componentin Angular is the building block of an application. 
- It defines the UI (template), behavior (class logic), and styles for a section of the app.

---

1. What is an Angular Component?
A component is a TypeScript class decorated with `@Component`. It has:  
- Template (HTML)→ Defines UI structure  
- Class (TS)→ Defines behavior and logic  
- Styles (CSS/SCSS)→ Defines appearance 
- Unit testing (spec.ts) -> For unit testing

- Ex:

  import { Component } from '@angular/core';

  @Component({
    selector: 'app-root', // HTML tag to use this component
    templateUrl: './app.component.html', // External HTML file
    styleUrls: ['./app.component.css'] // External CSS file
  })
  export class AppComponent {
    title = 'Angular Component Example';
  }


---

2. Why Are Components Used?
✅ Encapsulation– Each component is self-contained.  
✅ Reusability– Can be used multiple times in different parts of the app.  
✅ Modularity– Helps break down the app into small, manageable pieces.  
✅ Separation of Concerns– Keeps UI (`template`) separate from logic (`class`).  
✅ Data Binding– Supports easy interaction between UI and logic.  

---

3. Creating a Component
- You can create a component manually or using Angular CLI.
- ng generate component my-component
- ng g c my-component

- Creating component within a feature module via CLI:
ng g c module-name/component-name

This creates:

my-component/
│── my-component.component.ts  (Logic)
│── my-component.component.html (Template)
│── my-component.component.css  (Styles)
│── my-component.component.spec.ts (Test)


4. Manually Creating a Component
Create a `my-component.component.ts` file:

import { Component } from '@angular/core';

@Component({
  selector: 'app-my-component',
  template: `<h2>Welcome to My Component</h2>`,
  styles: [`h2 { color: blue; }`]
})
export class MyComponent {}

Now, add `<app-my-component></app-my-component>` in `app.component.html` to use it.


Note:
- If a component is generated via, CLI, then its automatically registered in declarations array of app.module.ts.
- For manually created compnent, we need to manually register it in app.module.ts.


---

4. Component Metadata (`@Component` Decorator)
The `@Component` decorator configures the component.


@Component({
  selector: 'app-example', // Custom HTML tag for the component
  template: `// html code`
  or
  templateUrl: './example.component.html', // External template file

  styles: `h3 {
    color: red;
    font-size:x-large
    }
    p {
      background-color: red;
    }`
  or
  styleUrls: ['./example.component.css'], // External styles

  // For Ngmodule less project (Angular 14+)
  standalone: true/false // Optional: Enables Standalone Components (Angular 14+) For (Angular 19 Specifying it not needed)
})

- If using -no--standalone project in Angular 14+, needs to explicilty specify in the cmponents that,
  standalone is false.


Properties of `@Component`
| Property      | Description |
|---------------|------------|
| `selector`    | HTML tag used to include the component |
| `templateUrl` | External HTML file |
| `template`    | Inline HTML template |
| `styleUrls`   | External CSS/SCSS files |
| `styles`      | Inline CSS styles |
| `standalone`  | Enables Standalone Components (Angular 14+) |

---

5. Component Styling
Angular components support:
- Global CSS(applies everywhere).
- Component-specific CSS(scoped to that component).
- Encapsulation Modes.

Encapsulation Modes
| Mode                                   | Behavior |
|----------------------------------------|----------|
| `ViewEncapsulation.Emulated` (default) | CSS applies only to that component. |
| `ViewEncapsulation.None`               | CSS is global. |
| `ViewEncapsulation.ShadowDom`          | Uses Shadow DOM for true encapsulation. |


Example:
@Component({
  selector: 'app-example',
  templateUrl: './example.component.html',
  styleUrls: ['./example.component.css'],
  encapsulation: ViewEncapsulation.None
})


6. Selector
- Custom HTML tag for the component
- <app-header></app-header> whereever these selectors are used, it renders the html of that selector in specified place.
- It can be named anything. But default naming convention is "prefix": "app" (which can be specified in angular.json) + "-" + component name (header)
- Ex: ng g c footer -> Then default selector is "app-footer"

i. Using selectors as an HTML element
- In .ts file,
    @Component (
      {
      selector:'app-first'
      }
    )
- Now it can be used as <app-first></app-first>.

- Best For:
  - Reusable UI components (e.g., <app-header>, <app-footer>, <app-sidebar>).
  - When the component represents a distinct UI block.


ii. Using selectors as an attribute
- In .ts file,
    @Component (
      {
      selector:'[app-first]'
      }
    )
- Now it cannnot be used as <app-first></app-first>. Instead it needs to be used as an attribute as follows.
  <div app-first></div>

- Best For:
  - Directives or behaviors that should be applied to existing elements.
  - When the component adds behavior but does not replace the element.


- Real-World Use Case:
  - Highlight text on hover:  <p appHighlight>Hover over me</p>
  - Add a tooltip: <button appTooltip="Click me!">Info</button>


iii. Using selectors as class
  @Component (
    {
      selector:'.app-first'
    }
  )

- Now it cannnot be used as <app-first></app-first>. Instead it needs to be used as an attribute as follows.
<div class="app-first"></div>

- Best For: 
  - When you want to apply styles via a component without modifying the element structure.
  - If you want multiple elements to behave the same way.


- Real-World Use Case:
Apply a reusable button design: <button class="app-button">Click Me</button>


iv. Using selectors as an ID (Not Recommended)
  @Component (
    {
      selector:'#app-first'
    }
  )

- Now it cannnot be used as <app-first></app-first>. Instead it needs to be used as an attribute as follows.
<div id="app-first"></div>

- Why It's Rarely Used?
  - ID selectors must be unique, so you can only use one per page.
  - Angular components are meant to be reusable.

- When Would This Be Useful?
  - If you want to enforce that a component appears only once (like a global toast message).
  - However, a service-based approach is a better alternative.

Most of the time only selector as HTML element is used.


---

# Data binding in Angular

 Data Binding in Angular (Detailed Explanation)  

 What is Data Binding?  
- Data binding in Angular is the mechanism that synchronizes data between the  model (TypeScript code) and the  view (HTML template) . 
- It allows dynamic updates in the UI whenever the data changes in the component, and vice versa.  

This eliminates the need for  manually querying the DOM and updating elements (as done in vanilla JavaScript or jQuery).  

---

I. Why is Data Binding Needed?  
1.  Dynamic UI Updates : Automatically updates the view when the data changes.  
2.  Better Code Maintainability : No need to manually modify the DOM.  
3.  Performance Optimization : Angular’s change detection ensures efficient updates.  
4.  Two-way Communication : Allows user inputs to be reflected in the component variables.  
5.  Simplifies Complex Applications : Managing UI state across components becomes easier.  

---

II. Types of Data Binding in Angular  

Angular provides  four types of data binding:  

| Type              | Direction        | Symbol        | Use Case |
|-------------------|------------------|---------------|-----------|
|  Interpolation    | Component → View | `{{}}`        | Display dynamic values in HTML |
|  Property Binding | Component → View | `[ ]`         | Bind component properties to element attributes |
|  Event Binding    | View → Component | `( )`         | Listen to events and execute component methods |
|  Two-Way Binding  | Component ⇆ View | `[(ngModel)]` | Sync data between UI and component |

---

1. Interpolation (`{{ }}`) - One-Way Binding (Component → View)  
- Used to  display data dynamically in the template.  
- Only works with string-based values (numbers, booleans, objects must be converted to strings). 
- you can write any valid TypeScript expression inside it. 
- However, the final result must be something that can be converted to a string, because interpolation sets the text content of an HTML element.
- Angular automatically converts them to strings when using interpolation.
- Uses  double curly braces `{{ }}` to embed expressions inside HTML.  

- Example  
  Component (TypeScript) :
  export class AppComponent {
    username: string = "Anish Bhandarkar";
  }

  Template (HTML):
  <h1>Welcome, {{ username }}</h1>

  Rendered Output:
  <h1>Welcome, Anish Bhandarkar</h1>

---

2. Property Binding (`[ ]`) - One-Way Binding (Component → View)  
- Used to  bind a component property to an HTML element's property/attribute.  
- Uses  square brackets `[ ]` .  
- Unlike interpolation, it  works with all data types (numbers, booleans, objects, arrays, etc.) .  

- Example  
  Component (TypeScript):
  export class AppComponent {
    imageUrl: string = "assets/profile.jpg";
  }

  Template (HTML):
  <img [src]="imageUrl" alt="Profile Image">

  Equivalent HTML Output:
  <img src="assets/profile.jpg" alt="Profile Image">


 Difference Between Interpolation and Property Binding 
| Feature       | Interpolation (`{{}}`)    | Property Binding (`[ ]`) |
|---------------|---------------------------|----------------------|
|  Binding Type | Binds as text content     | Binds as an actual property |
|  Works With   | Only strings              | All types (booleans, numbers, objects, etc.) |
|  Use Case     | Text inside HTML elements | Dynamic attribute values (like `src`, `disabled`, `value`) |

---

 3. Event Binding (`( )`) - One-Way Binding (View → Component)  
- Used to  isten to user events (click, keypress, mouseover, input, change, etc.).  
- Uses parentheses `( )` around the event name.  
- Calls a method in the component when the event occurs.  

-Example  
 Component (TypeScript) :
  export class AppComponent {
    count: number = 0;

    increment() {
      this.count++;
    }
  }

  Template (HTML) :
  <button (click)="increment()">Click Me</button>
  <p>Count: {{ count }}</p>

-Behavior 
  - When the button is clicked, the `increment()` method runs.  
  - `count` increases and the new value is reflected in the UI.  

---

4. Two-Way Binding (`[()]`) - (Component ⇆ View)  
-  Combines Property Binding (`[ ]`) and Event Binding (`( )`) .  
- Uses  banana-in-a-box syntax `[()]`.  
- Mostly used for  form inputs (`<input>`, `<textarea>`, `<select>`, etc.).  
- Requires `FormsModule` in `app.module.ts`.  

-Example :
 Component (TypeScript): 
  export class AppComponent {
    username: string = "";
  }

  Template (HTML) :
  <input [(ngModel)]="username" placeholder="Enter your name">
  <p>Hello, {{ username }}</p>

-Behavior 
  - As the user types in the input, `username` updates in real time.  
  - The `{{ username }}` also updates dynamically.  

- Module Configuration (app.module.ts) 
  import { NgModule } from '@angular/core';
  import { FormsModule } from '@angular/forms';

  @NgModule({
    imports: [FormsModule]
  })
  export class AppModule { }


---

 Other Advanced Data Binding Techniques  

 5. Attribute Binding (`[attr.]`)  
- Binds values to HTML attributes that are not standard properties.  
- Example: `aria-label`, `data-*`, `role`, `colspan`.  

<button [attr.aria-label]="'Submit Button'">Submit</button>


 6. Class Binding (`[class.]`)  
- Dynamically applies CSS classes.  

<p [class.active]="isActive">This text changes color</p>


isActive = true;


 7. Style Binding (`[style.]`)  
- Dynamically applies inline styles.  

<p [style.color]="isRed ? 'red' : 'black'">Styled Text</p>


isRed = true;


8. bind- Syntax:
- Old syntax of alternative way of property binding.
- bind-*
- Ex:
  <img bind-src="imageUrl">
  // same as,
  <img [src]="imageUrl">


---

Summary Table  

| Type               | Syntax     | Direction        | Example |
|--------------------|------------|------------------|---------|
|  Interpolation     | `{{ }}`    | Component → View | `<p>{{ username }}</p>` |
|  Property Binding  | `[ ]`      | Component → View | `<img [src]="imageUrl">` |
|  Event Binding     | `( )`      | View → Component | `<button (click)="increment()">` |
|  Two-Way Binding   | `[()]`     | Component ⇆ View | `<input [(ngModel)]="username">` |
|  Attribute Binding | `[attr.]`  | Component → View | `<button [attr.aria-label]="'Submit'">` |
|  Class Binding     | `[class.]` | Component → View | `<p [class.active]="isActive">` |
|  Style Binding     | `[style.]` | Component → View | `<p [style.color]="'red'">` |

---

Final Thoughts  
-  Use interpolation (`{{ }}`) for inline text content.  
-  Use property binding (`[ ]`) for setting attributes dynamically.  
-  Use event binding (`( )`) for handling user interactions.  
-  Use two-way binding (`[()]`) when you need to sync user input with component variables.  





































// TODO:
1) Demonstrate how angular is SPA?
2) IN Angular 14+ (17) modules are not used. How to use standalone comp? Command to use modules in Ang 17 ... (Refer temp.txt)